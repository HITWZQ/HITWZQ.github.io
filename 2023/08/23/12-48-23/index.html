<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"hitwzq.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="排序最小的k个数剑指 Offer 40. 最小的k个数 - 力扣（LeetCode） 基础知识堆堆（Heap）是一种基于完全二叉树结构的数据结构，具有以下特点：  堆的性质（最大堆和最小堆）：堆可以分为最大堆和最小堆两种类型。在最大堆中，父节点的值大于或等于其子节点的值，即堆顶元素是最大的；而在最小堆中，父节点的值小于或等于其子节点的值，即堆顶元素是最小的。这种性质使得堆顶元素具有一定的顺序关系，">
<meta property="og:type" content="article">
<meta property="og:title" content="排序">
<meta property="og:url" content="https://hitwzq.github.io/2023/08/23/12-48-23/index.html">
<meta property="og:site_name" content="HITWZQ的个人博客">
<meta property="og:description" content="排序最小的k个数剑指 Offer 40. 最小的k个数 - 力扣（LeetCode） 基础知识堆堆（Heap）是一种基于完全二叉树结构的数据结构，具有以下特点：  堆的性质（最大堆和最小堆）：堆可以分为最大堆和最小堆两种类型。在最大堆中，父节点的值大于或等于其子节点的值，即堆顶元素是最大的；而在最小堆中，父节点的值小于或等于其子节点的值，即堆顶元素是最小的。这种性质使得堆顶元素具有一定的顺序关系，">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-08-23T04:48:23.000Z">
<meta property="article:modified_time" content="2023-08-24T10:09:20.319Z">
<meta property="article:author" content="Rachel">
<meta property="article:tag" content="秋招">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://hitwzq.github.io/2023/08/23/12-48-23/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://hitwzq.github.io/2023/08/23/12-48-23/","path":"2023/08/23/12-48-23/","title":"排序"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>排序 | HITWZQ的个人博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">HITWZQ的个人博客</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F"><span class="nav-number">1.</span> <span class="nav-text">排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0"><span class="nav-number">1.1.</span> <span class="nav-text">最小的k个数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-number">1.1.1.</span> <span class="nav-text">基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A0%86"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">堆</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">快速排序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF"><span class="nav-number">1.1.2.</span> <span class="nav-text">思路</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%A7%E6%A0%B9%E5%A0%86"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">大根堆</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-1"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">快速排序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF"><span class="nav-number">1.1.3.</span> <span class="nav-text">错误</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E5%A4%A7%E6%A0%B9%E5%A0%86"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">用大根堆</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-2"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">快速排序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81"><span class="nav-number">1.1.4.</span> <span class="nav-text">代码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%A7%E6%A0%B9%E5%A0%86-1"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">大根堆</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-3"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">快速排序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="nav-number">1.2.</span> <span class="nav-text">数据流中位数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-1"><span class="nav-number">1.2.1.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-1"><span class="nav-number">1.2.2.</span> <span class="nav-text">基础知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF-1"><span class="nav-number">1.2.3.</span> <span class="nav-text">错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="nav-number">1.2.4.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9"><span class="nav-number">1.3.</span> <span class="nav-text">数组中的逆序对</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-2"><span class="nav-number">1.3.1.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF-2"><span class="nav-number">1.3.2.</span> <span class="nav-text">错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-2"><span class="nav-number">1.3.3.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-number">1.4.</span> <span class="nav-text">合并K个升序链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-3"><span class="nav-number">1.4.1.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-2"><span class="nav-number">1.4.2.</span> <span class="nav-text">基础知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98"><span class="nav-number">1.4.3.</span> <span class="nav-text">问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">归并排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">优先队列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF-3"><span class="nav-number">1.4.4.</span> <span class="nav-text">错误</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%9A"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">归并排序：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97-1"><span class="nav-number">1.4.4.2.</span> <span class="nav-text">优先队列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-3"><span class="nav-number">1.4.5.</span> <span class="nav-text">代码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-1"><span class="nav-number">1.4.5.1.</span> <span class="nav-text">归并排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97-2"><span class="nav-number">1.4.5.2.</span> <span class="nav-text">优先队列</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="nav-number">1.5.</span> <span class="nav-text">合并两个有序数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-4"><span class="nav-number">1.5.1.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF-4"><span class="nav-number">1.5.2.</span> <span class="nav-text">错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-4"><span class="nav-number">1.5.3.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB"><span class="nav-number">1.6.</span> <span class="nav-text">颜色分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-5"><span class="nav-number">1.6.1.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF-5"><span class="nav-number">1.6.2.</span> <span class="nav-text">错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-5"><span class="nav-number">1.6.3.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%83%A8%E5%88%86%E6%8E%92%E5%BA%8F"><span class="nav-number">1.7.</span> <span class="nav-text">部分排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-6"><span class="nav-number">1.7.1.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF-6"><span class="nav-number">1.7.2.</span> <span class="nav-text">错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-6"><span class="nav-number">1.7.3.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E5%8F%B3%E4%BE%A7%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-number">1.8.</span> <span class="nav-text">计算右侧小于当前元素的个数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-7"><span class="nav-number">1.8.1.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF-7"><span class="nav-number">1.8.2.</span> <span class="nav-text">错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-7"><span class="nav-number">1.8.3.</span> <span class="nav-text">代码</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Rachel</p>
  <div class="site-description" itemprop="description">学习，记录，积累</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://hitwzq.github.io/2023/08/23/12-48-23/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rachel">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HITWZQ的个人博客">
      <meta itemprop="description" content="学习，记录，积累">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="排序 | HITWZQ的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          排序
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-08-23 12:48:23" itemprop="dateCreated datePublished" datetime="2023-08-23T12:48:23+08:00">2023-08-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-08-24 18:09:20" itemprop="dateModified" datetime="2023-08-24T18:09:20+08:00">2023-08-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/LeetCode/%E6%8E%92%E5%BA%8F/" itemprop="url" rel="index"><span itemprop="name">排序</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="最小的k个数"><a href="#最小的k个数" class="headerlink" title="最小的k个数"></a>最小的k个数</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/">剑指 Offer 40. 最小的k个数 - 力扣（LeetCode）</a></p>
<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>堆（Heap）是一种基于完全二叉树结构的数据结构，具有以下特点：</p>
<ol>
<li><strong>堆的性质（最大堆和最小堆）</strong>：堆可以分为最大堆和最小堆两种类型。在最大堆中，父节点的值大于或等于其子节点的值，即堆顶元素是最大的；而在最小堆中，父节点的值小于或等于其子节点的值，即堆顶元素是最小的。这种性质使得堆顶元素具有一定的顺序关系，而子树的结构没有特定的顺序。</li>
<li><strong>堆的结构性质</strong>：堆是一棵完全二叉树，即除了最底层，其他层的节点都是满的，且最底层的节点尽可能地靠左排列。</li>
</ol>
<p>堆通常用于实现优先队列、堆排序等算法，因为它能够在O(logN)的时间内执行插入、删除等操作，使其在动态维护一组元素的过程中非常高效。</p>
<p>堆可以使用数组来实现，其中节点的索引关系满足一定的规则。比如，对于一个索引为i的节点，其父节点的索引是(i-1)&#x2F;2，而左子节点的索引是2<em>i+1，右子节点的索引是2</em>i+2。</p>
<p>堆的操作包括：</p>
<ul>
<li>插入（Insertion）：将一个新元素添加到堆中，然后通过一系列调整操作维持堆的性质。</li>
<li>删除堆顶元素（Deletion）：移除堆顶元素，然后将最后一个元素放到堆顶，再通过一系列调整操作维持堆的性质。</li>
<li>查找堆顶元素（Top）：返回堆顶元素，也就是最大（或最小）元素。</li>
<li>堆化（Heapify）：将一个无序数组转换为堆结构，通常是通过从最后一个非叶节点开始，逐级进行向下调整的过程。</li>
</ul>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><ol>
<li><strong>分割阶段</strong>：选择一个基准元素（通常是数组中的一个元素），将数组分割成两个子数组，一个小于基准元素的子数组，一个大于基准元素的子数组。这个过程被称为分割（Partitioning）。</li>
<li><strong>递归阶段</strong>：对分割后的两个子数组递归地应用快速排序算法，将它们分别排序。</li>
<li><strong>合并阶段</strong>：将排序后的子数组合并起来，就得到了完整的有序数组。</li>
</ol>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="大根堆"><a href="#大根堆" class="headerlink" title="大根堆"></a>大根堆</h4><ol>
<li><p>用大根堆维护前k小值，将前k个元素插入堆中；之后的元素与堆顶比较即可，小即插入；</p>
<ol>
<li><p>C++ 语言中的堆（即优先队列）为大根堆</p>
</li>
<li><p>为什么找出最小的k个数要用大根堆：对于最大队维护维护最小值的情况，如果说新加入一个最小的新数值，对于当前的大根堆来说，顶端值是最大的，所以说我们要把这个最大的扔出去，再把这个最小的加起来。所以说它是可以维护当前最小的值，那么同理对于小根堆维护最大值也是一样的。</p>
</li>
<li><p>对于大根堆插入的时间复杂度：<br>$$<br>O(log⁡k)<br>$$</p>
</li>
</ol>
</li>
</ol>
<h4 id="快速排序-1"><a href="#快速排序-1" class="headerlink" title="快速排序"></a>快速排序</h4><ol>
<li>直接排序</li>
<li>只要求返回最小的 k 个数，对这 k 个数的顺序并没有要求。因此，只需要将数组划分为 <strong>最小的 k个数</strong> 和 <strong>其他数字</strong> 两部分即可；考虑在每次哨兵划分后，判断基准数在数组中的索引是否等于 k，若 true则直接返回此时数组的前 <em>k</em>个数字即可。<ol>
<li>什么时候终止递归：i&#x3D;&#x3D;k</li>
</ol>
</li>
</ol>
<h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><h4 id="用大根堆"><a href="#用大根堆" class="headerlink" title="用大根堆"></a>用大根堆</h4><ol>
<li>如何创建大根堆：priority_queue<int> Q;</li>
<li>vector初始化： vector<int> result**(k,0)**</li>
<li>不是push i插入的是数组值</li>
</ol>
<h4 id="快速排序-2"><a href="#快速排序-2" class="headerlink" title="快速排序"></a>快速排序</h4><ol>
<li><p>左哨兵i挪动的时候是&lt;&#x3D;，而不是&lt;</p>
</li>
<li><p>忘记加终止递归的条件</p>
</li>
<li><p>i和k比较大小之后怎么递归调用：就是右子序列递归的时候，代表第 k+1小的数字在右子数组中，则递归右子数组；</p>
</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="大根堆-1"><a href="#大根堆-1" class="headerlink" title="大根堆"></a>大根堆</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(k,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> n=arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            Q.<span class="built_in">push</span>(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=k;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&lt;Q.<span class="built_in">top</span>())&#123;</span><br><span class="line">                Q.<span class="built_in">pop</span>();</span><br><span class="line">                Q.<span class="built_in">push</span>(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            result[i]=Q.<span class="built_in">top</span>();</span><br><span class="line">            Q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="快速排序-3"><a href="#快速排序-3" class="headerlink" title="快速排序"></a>快速排序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;arr,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> i=l;</span><br><span class="line">        <span class="type">int</span> j=r;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(arr[j]&gt;=arr[l]&amp;&amp;i&lt;j)   j--;</span><br><span class="line">            <span class="keyword">while</span>(arr[i]&lt;=arr[l]&amp;&amp;i&lt;j)   i++;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i],arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(arr[l],arr[i]);</span><br><span class="line">        <span class="built_in">quickSort</span>(arr,l,i<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">quickSort</span>(arr,i+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">quickSort</span>(arr,<span class="number">0</span>,arr.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)    result.<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第二种快排：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;arr,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> i=l;</span><br><span class="line">        <span class="type">int</span> j=r;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(arr[j]&gt;=arr[l]&amp;&amp;i&lt;j)   j--;</span><br><span class="line">            <span class="keyword">while</span>(arr[i]&lt;=arr[l]&amp;&amp;i&lt;j)   i++;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i],arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(arr[l],arr[i]);</span><br><span class="line">        <span class="built_in">quickSort</span>(arr,l,i<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">quickSort</span>(arr,i+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">quickSort</span>(arr,<span class="number">0</span>,arr.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)    result.<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="数据流中位数"><a href="#数据流中位数" class="headerlink" title="数据流中位数"></a>数据流中位数</h2><p>[295. 数据流的中位数 - 力扣（LeetCode）](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-median-from-data-stream/">https://leetcode.cn/problems/find-median-from-data-stream/</a></p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>建立一个 小顶堆 AAA 和 大顶堆 BBB ，各保存列表的一半元素，且规定：</p>
<p>​	A保存 <strong>较大</strong> 的一半,B 保存 <strong>较小</strong> 的一半；</p>
<p>设元素总数为 N&#x3D;m+n ，其中 m 和 n分别为 A 和 B中的元素个数，保持m&gt;&#x3D;n</p>
<p>插入的时候，如果说M大于N，那么这个时候新的插入就往B里面去放，但是新插入的这个元素又不一定属于较小的一半，所以说我们需要先把这个数字插入到小根堆当中，再把A的top push进B里面去然后再popA。</p>
<h3 id="基础知识-1"><a href="#基础知识-1" class="headerlink" title="基础知识"></a>基础知识</h3><ol>
<li><p>priority_queue&lt;int, vector<int>, greater<int>&gt; A的第二个参数，第三个参数是什么意思</p>
<ol>
<li><p><strong>第二个参数：底层容器类型</strong></p>
<p><code>priority_queue</code> 的第二个参数指定底层容器的类型。在你的代码中，<code>vector&lt;int&gt;</code> 被用作底层容器，这意味着底层实际上使用了一个 <code>vector</code> 来存储元素。</p>
<p><strong><code>deque</code>（双端队列）</strong>也可以作为 <code>priority_queue</code> 的底层容器</p>
</li>
<li><p><strong>第三个参数：比较函数对象</strong></p>
<p><code>priority_queue</code> 的第三个参数是一个可选参数，用于指定比较函数。比较函数决定了堆中元素的排列顺序，从而影响堆顶元素的选择。</p>
<ul>
<li><code>greater&lt;int&gt;</code>：这是一个函数对象，它定义了一个比较操作，用于将元素按照从小到大的顺序排列。也就是说，堆顶元素将是队列中的最小元素。</li>
<li><code>less&lt;int&gt;</code>：与 <code>greater</code> 相反，它定义了一个比较操作，用于将元素按照从大到小的顺序排列，堆顶元素将是队列中的最大元素。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="错误-1"><a href="#错误-1" class="headerlink" title="错误"></a>错误</h3><ol>
<li>小根堆的默认方式</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt; A;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>size（）</li>
</ol>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt; A;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt;&gt; B;</span><br><span class="line">    <span class="built_in">MedianFinder</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addNum</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A.<span class="built_in">size</span>()!=B.<span class="built_in">size</span>())&#123;</span><br><span class="line">            A.<span class="built_in">push</span>(num);</span><br><span class="line">            B.<span class="built_in">push</span>(A.<span class="built_in">top</span>());</span><br><span class="line">            A.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            B.<span class="built_in">push</span>(num);</span><br><span class="line">            A.<span class="built_in">push</span>(B.<span class="built_in">top</span>());</span><br><span class="line">            B.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (A.<span class="built_in">size</span>()==B.<span class="built_in">size</span>()?(A.<span class="built_in">top</span>()+B.<span class="built_in">top</span>())/<span class="number">2.0</span>:A.<span class="built_in">top</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">剑指 Offer 51. 数组中的逆序对 - 力扣（LeetCode）</a></p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p><strong>「归并排序」与「逆序对」是息息相关的</strong></p>
<p>在合并阶段，每当遇到 ij没到头左子数组当前元素 &gt; 右子数组当前元素，意味着 「左子数组当前元素 至 末尾元素」 与 「右子数组当前元素」 构成了若干 「逆序对」 。</p>
<h3 id="错误-2"><a href="#错误-2" class="headerlink" title="错误"></a>错误</h3><ol>
<li><p>是划分结束进行合并吗</p>
<p>是的，划分到长度为1的子数组，然后在合并的过程中计算逆序对的数量并排序</p>
</li>
<li><p>为什么没有另外申请空间存储返回值</p>
<p>就是res返回值</p>
</li>
<li><p>暂存数组 nums 闭区间lr内的元素至辅助数组是什么作用？</p>
<p>排序后的元素可能会覆盖掉原数组中未排序的元素，因此需要一个临时的数组来存储合并过程中的中间结果；</p>
</li>
<li><p>正常的合并是什么样子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (i &lt;= m &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp[i] &lt;= tmp[j]) nums[k++] = tmp[i++];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[k++] = tmp[j++];</span><br><span class="line">                res += m - i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= m) nums[k++] = tmp[i++];</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= r) nums[k++] = tmp[j++];</span><br></pre></td></tr></table></figure>


</li>
<li><p>left和right是左闭右闭</p>
</li>
<li><p>调换顺序的问题： 不知道为什么，{ 233,2000000001,234,2000000006,235,2000000003,236,2000000007,237,2000000002,2000000005,233,233,233,233,233,2000000004 };就是在不越界的情况下先循环填充再重复剩下的，剩下的两个while条件调换是可以的。</p>
</li>
</ol>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reversePairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">mergeSortI</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span>  <span class="title">mergeSortI</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r, vector&lt;<span class="type">int</span>&gt;&amp; tmp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> res=<span class="built_in">mergeSortI</span>(nums, l, m, tmp)+ <span class="built_in">mergeSortI</span>(nums, m + <span class="number">1</span>, r, tmp);</span><br><span class="line">        <span class="type">int</span> k = l;</span><br><span class="line">        <span class="keyword">for</span> (k = l; k &lt;= r; k++) &#123;</span><br><span class="line">            tmp[k] = nums[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i = l, j = m + <span class="number">1</span>;</span><br><span class="line">        k = l;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= m &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp[i] &lt;= tmp[j]) nums[k++] = tmp[i++];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[k++] = tmp[j++];</span><br><span class="line">                res += m - i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= r) nums[k++] = tmp[j++];</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= m) nums[k++] = tmp[i++];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="合并K个升序链表"><a href="#合并K个升序链表" class="headerlink" title="合并K个升序链表"></a>合并K个升序链表</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-k-sorted-lists/">23. 合并 K 个升序链表 - 力扣（LeetCode）</a></p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol>
<li><p>采用归并排序，需要合并两个链表</p>
<ol>
<li>先合并两个链表</li>
<li>再递归合并</li>
</ol>
</li>
<li><p>优先队列</p>
<ol>
<li>创建优先队列并使用推导指引自定义比较函数与初始元素</li>
</ol>
</li>
</ol>
<h3 id="基础知识-2"><a href="#基础知识-2" class="headerlink" title="基础知识"></a>基础知识</h3><ol>
<li><code>remove_if</code>：这是一个标准库算法，用于在指定范围内移除满足特定条件的元素。它接受三个参数：起始迭代器、终止迭代器和一个谓词（predicate）函数，将满足条件的元素移动到容器的末尾，不过并没有真正删除这些元素，而是将它们移到了末尾，并返回一个新的终止迭代器，指向这些被移动的元素之后的位置。</li>
<li><code>lists.erase(..., lists.end())</code>：最终，使用 <code>erase</code> 函数来删除已经被移动到容器末尾的元素。<code>erase</code> 函数接受一个范围，由两个迭代器指定。</li>
</ol>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><ol>
<li><p>如果采取归并排序的思想要怎么才能确定链表的l和r</p>
<p>传入的是一个链表数组</p>
</li>
<li><p>为甚么要分成三个函数去写</p>
<p>之前的正常归并排序是两个数组：第一，这里是多个；第二，如果是换成合并多个数组也是一样的</p>
</li>
</ol>
<h4 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h4><ol>
<li><p>推导指引</p>
<ol>
<li><code>lists</code> 的作用是为优先队列提供初始元素。</li>
<li>我只知道利用匿名函数可以这么干，但是目前还不是很清楚为什么建立的是小根堆：比较函数的性质：如果 <code>a</code> 的 <code>val</code> 大于 <code>b</code> 的 <code>val</code>，则返回 <code>true</code>，表示 <code>a</code> 应该排在 <code>b</code> 前面</li>
</ol>
</li>
<li><p>怎么从原链表中获取下一个节点放入堆中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = p-&gt;next = q.<span class="built_in">top</span>();</span><br><span class="line"><span class="keyword">if</span> (p-&gt;next) q.<span class="built_in">push</span>(p-&gt;next);</span><br></pre></td></tr></table></figure>
</li>
<li><p>小根堆：比较函数 <code>[](auto&amp; a, auto&amp; b) &#123; return a-&gt;val &gt; b-&gt;val; &#125;</code> 表示如果 <code>a-&gt;val</code> 大于 <code>b-&gt;val</code>，则 <code>a</code> 更小</p>
</li>
<li><p>一个节点为空时怎么处理：队列会push他的下一个，当p-&gt;next为空时，队列还不是空，继续进入循环，p-&gt;next赋值为top()</p>
</li>
</ol>
<h3 id="错误-3"><a href="#错误-3" class="headerlink" title="错误"></a>错误</h3><h4 id="归并排序："><a href="#归并排序：" class="headerlink" title="归并排序："></a>归并排序：</h4><ol>
<li>head没初始化</li>
<li>访问空指针：ij不是ab</li>
</ol>
<h4 id="优先队列-1"><a href="#优先队列-1" class="headerlink" title="优先队列"></a>优先队列</h4><ol>
<li>没有将容器中的空节点删除（不删在优先队列初始化的时候会有问题）</li>
<li>匿名函数语句忘记加分号</li>
<li>优先队列为空不用空指针，empty函数</li>
<li>head没初始化，如果new的话还得删除；不如直接head是节点不是指针</li>
</ol>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><h4 id="归并排序-1"><a href="#归并排序-1" class="headerlink" title="归并排序"></a>归并排序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* a, ListNode* b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((!a) || (!b))    <span class="keyword">return</span> a ? a : b;</span><br><span class="line">        ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        ListNode* tail = head;</span><br><span class="line">        ListNode* i = a;</span><br><span class="line">        ListNode* j = b;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (i &amp;&amp; j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i-&gt;val &lt;= j-&gt;val) &#123;</span><br><span class="line">                tail-&gt;next = i;</span><br><span class="line">                i = i-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail-&gt;next = j;</span><br><span class="line">                j = j-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        tail-&gt;next = i ? i : j;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r)    <span class="keyword">return</span> lists[l];</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> m=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mergeTwoLists</span>(<span class="built_in">merge</span>(lists,l,m),<span class="built_in">merge</span>(lists,m+<span class="number">1</span>,r));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(lists,<span class="number">0</span>,lists.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="优先队列-2"><a href="#优先队列-2" class="headerlink" title="优先队列"></a>优先队列</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        lists.<span class="built_in">erase</span>(<span class="built_in">remove_if</span>(lists.<span class="built_in">begin</span>(),</span><br><span class="line">                                lists.<span class="built_in">end</span>(),</span><br><span class="line">                                [](<span class="keyword">auto</span> a)&#123;<span class="keyword">return</span> !a;&#125;),</span><br><span class="line">                              lists.<span class="built_in">end</span>());</span><br><span class="line">        priority_queue q&#123;[](<span class="keyword">auto</span>&amp; a,<span class="keyword">auto</span>&amp; b)&#123;<span class="keyword">return</span> a-&gt;val&gt;b-&gt;val;&#125;,lists&#125;;</span><br><span class="line">        ListNode head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p=&amp;head;!q.<span class="built_in">empty</span>();q.<span class="built_in">pop</span>())&#123;</span><br><span class="line">            p-&gt;next=q.<span class="built_in">top</span>();</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next) q.<span class="built_in">push</span>(p-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-sorted-array">力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台</a></p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>直接覆盖原0后快速排序返回</p>
<h3 id="错误-4"><a href="#错误-4" class="headerlink" title="错误"></a>错误</h3><ol>
<li>m，n含义没搞清楚</li>
<li>快速排序不是很熟悉，两个return是递归结束和其他递归返回</li>
</ol>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> i=l;</span><br><span class="line">        <span class="type">int</span> j=r;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[j]&gt;=nums[l]&amp;&amp;i&lt;j) j--;</span><br><span class="line">            <span class="keyword">while</span>(nums[i]&lt;=nums[l]&amp;&amp;i&lt;j) i++;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i],nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[l],nums[i]);</span><br><span class="line">        <span class="built_in">quickSort</span>(nums,l,i<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">quickSort</span>(nums,i+<span class="number">1</span>,r);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                nums1[i+m]=nums2[i];</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="built_in">quickSort</span>(nums1,<span class="number">0</span>,m+n<span class="number">-1</span>);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="颜色分类"><a href="#颜色分类" class="headerlink" title="颜色分类"></a>颜色分类</h2><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><ol>
<li><p>直接先排序（快排）</p>
</li>
<li><p>进阶：快排的空间复杂度和时间复杂度取决于递归的次数</p>
<ol>
<li><p>时间: 最好情况每次递归都平分数组，一共需要递归<br>$$<br>logn<br>$$<br>次，每次需要n时间，复杂度为<br>$$<br>O(n*logn)<br>$$<br>最坏情况每次都把数组分成1和n-1，一共需要递归n次，每次需要n时间，总体复杂度为<br>$$<br>O(n^2)。<br>$$<br>平均总体时间复杂度为<br>$$<br>O(nlogn)<br>$$<br>。</p>
</li>
<li><p>空间: 和时间复杂度相关，每次递归需要的空间是固定的，总体空间复杂度即为递归层数，因此平均&#x2F;最好空间复杂度为<br>$$<br>O(logn)<br>$$<br>最坏空间复杂度为<br>$$<br>O(n)<br>$$</p>
</li>
<li><p>空间复杂度为O(1)也就是说通过一次遍历，把数组分成三个部分</p>
<ol>
<li>需要找出所有的 000 交换至数组的头部，并且找出所有的 222 交换至数组的尾部，一个指针 p2  是从右向左移动的，因此当我们在从左向右遍历整个数组时，如果遍历到的位置超过了p2 ，那么就可以直接停止遍历了。注意碰到2的时候交换过来什么并不知道所以i不能移动。</li>
<li>同样也是双指针，一定要注意区间的开闭，这里选择左闭右开（01），2选择左开右闭；所以循环遍历到i&lt;&#x3D;p2</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="错误-5"><a href="#错误-5" class="headerlink" title="错误"></a>错误</h3><ol>
<li>区间的定义</li>
<li>交换1的时候为什么可以确定挪动i，因为i左边的不是0就是1，</li>
</ol>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sortColors</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> p0=<span class="number">0</span>,p2=n<span class="number">-1</span>,i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=p2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i],nums[p0]);</span><br><span class="line">                p0++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]==<span class="number">1</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i],nums[p2]);</span><br><span class="line">                p2--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="部分排序"><a href="#部分排序" class="headerlink" title="部分排序"></a>部分排序</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sub-sort-lcci/">面试题 16.16. 部分排序 - 力扣（LeetCode）</a></p>
<h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>排序前后的数组对比，从第一个开始不一样的入栈到最后一个不一样的</p>
<h3 id="错误-6"><a href="#错误-6" class="headerlink" title="错误"></a>错误</h3><p>返回错了，题目要求的是下标范围</p>
<h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">subSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; array)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; tmp=array;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(tmp.<span class="built_in">begin</span>(),tmp.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;array.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i]!=tmp[i])    res.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">size</span>()?vector&lt;<span class="type">int</span>&gt;&#123;res[<span class="number">0</span>],res.<span class="built_in">back</span>()&#125;:vector&lt;<span class="type">int</span>&gt; &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="计算右侧小于当前元素的个数"><a href="#计算右侧小于当前元素的个数" class="headerlink" title="计算右侧小于当前元素的个数"></a>计算右侧小于当前元素的个数</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-of-smaller-numbers-after-self/">315. 计算右侧小于当前元素的个数 - 力扣（LeetCode）</a></p>
<h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>类似于逆序对，采用归并排序</p>
<p>流程：归并排序+索引下标+计算返回值</p>
<ol>
<li>需要加入索引下标，在遍历的时候<strong>如何获取当前元素的下标</strong>：比如我们想要排序 5261，在最后一次递归的时候得到2516，存在tmp里而且知道对应的下标。</li>
<li>关于计算是在左归的时候计算还是在右归的时候计算：当前左数 &lt; &#x3D; 右数 , 说明右数已合并的数，都小于该左数；需要统计进去，即 res[indexes[k]] +&#x3D; (j - mid - 1);代码<ol>
<li>有没有可能出现当前左数 &lt; &#x3D; 右数 , 说明右数已合并的数大于该左数的情况：实际上不可能，因为EX:25 36，i指向2，j指向6这种是不可能的，因为在j指向3时i一定会移动</li>
</ol>
</li>
</ol>
<h3 id="错误-7"><a href="#错误-7" class="headerlink" title="错误"></a>错误</h3><ol>
<li><p>[1,0,1,0]不管左归右归都是这个结果</p>
<ol>
<li>debug发现整个nums就不对，整体的逻辑没错，debug<ol>
<li><code>res[nums[i].second] += j - m - 1</code>是不对的，tmp是新复制的数组，应该是<code>res[tmp[i].second] += j - m - 1;</code></li>
</ol>
</li>
</ol>
</li>
<li><p>为什么和逆序对不一样：当前左数 &lt; &#x3D; 右数 , 说明右数已合并的数，都小于该左数；需要统计进去，即 res[indexes[k]] +&#x3D; (j - mid - 1);代码</p>
</li>
<li><p>忘记初始化返回vector</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(vec.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line"><span class="comment">//res =(vec.size(), 0);</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>tmp需要实现指定范围</p>
</li>
<li><p>忘记递归排序左右部分</p>
</li>
</ol>
<h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countSmaller</span><span class="params">(vector&lt;<span class="type">int</span>&gt; vec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (vec.<span class="built_in">empty</span>())    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; nums;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            nums.<span class="built_in">emplace_back</span>(vec[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">tmp</span>(vec.<span class="built_in">size</span>());</span><br><span class="line">        res = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(vec.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">mergeSort</span>(nums, <span class="number">0</span>, vec.<span class="built_in">size</span>() - <span class="number">1</span>, tmp);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&amp; tmp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r)    <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> i = l, j = m+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">mergeSort</span>(nums, l, m, tmp); <span class="built_in">mergeSort</span>(nums, m + <span class="number">1</span>, r, tmp);</span><br><span class="line">        <span class="type">int</span> k = l;</span><br><span class="line">        <span class="keyword">for</span> (k = l; k &lt;= r; k++) &#123;</span><br><span class="line">            tmp[k] = nums[k];</span><br><span class="line">        &#125;</span><br><span class="line">        k = l;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;=m&amp;&amp;j&lt;=r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp[i].first &lt;= tmp[j].first) &#123;</span><br><span class="line">                res[tmp[i].second] += j - m - <span class="number">1</span>;</span><br><span class="line">                nums[k++] = tmp[i++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                nums[k++] = tmp[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;=m)</span><br><span class="line">        &#123;</span><br><span class="line">            res[tmp[i].second] += j - m - <span class="number">1</span>;</span><br><span class="line">            nums[k++] = tmp[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=r)  nums[k++] = tmp[j++];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%A7%8B%E6%8B%9B/" rel="tag"># 秋招</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/08/22/11-32-32/" rel="prev" title="哈希表">
                  <i class="fa fa-angle-left"></i> 哈希表
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Rachel</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  





</body>
</html>
