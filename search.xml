<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2023/08/15/00-00-00/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2023/08/15/12-16-22/</url>
    <content><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><ol>
<li>指针的问题，什么时候停止循环</li>
<li>记得反转</li>
</ol>
<h2 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h2><p>一开始是想反转链表但是题目要求不能改变原来链表结构所以作罢</p>
<p>总的思想是需要先将两个链表对齐，这样在一个循环里才能一起往后移动一个长度；需要注意的是使用了swap函数，让A始终是较长的那一个。</p>
<p>swap支持类型：</p>
<ol>
<li><strong>整数类型</strong>：包括<code>int</code>、<code>long</code>、<code>short</code>等等。</li>
<li><strong>浮点数类型</strong>：包括<code>float</code>、<code>double</code>等等。</li>
<li><strong>字符类型</strong>：包括<code>char</code>、<code>wchar_t</code>等等。</li>
<li><strong>布尔类型</strong>：<code>bool</code>类型。</li>
<li><strong>指针类型</strong>：可以交换指向不同数据类型的指针。</li>
<li><strong>自定义类型</strong>：只要你的类型实现了必要的操作符（如赋值运算符 <code>=</code>），就可以在<code>std::swap</code>中使用。</li>
<li><strong>STL容器和算法类型</strong>：<code>std::vector</code>、<code>std::string</code>、<code>std::list</code>等STL容器，以及其他自定义的容器类型。</li>
<li><strong>用户自定义类和结构体</strong>：只要你的类或结构体定义了合适的拷贝构造函数、析构函数和赋值运算符，就可以在<code>std::swap</code>中使用</li>
</ol>
<h2 id="合并有序链表"><a href="#合并有序链表" class="headerlink" title="合并有序链表"></a>合并有序链表</h2><p>判断老是写成赋值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list2==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list1-&gt;val&lt;list2-&gt;val)&#123;</span><br><span class="line">            list1-&gt;next=<span class="built_in">mergeTwoLists</span>(list1-&gt;next,list2);</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            list2-&gt;next=<span class="built_in">mergeTwoLists</span>(list1,list2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>主要使用递归，每次返回都是新链表的头，结束条件是有一个走到最后；</p>
<h2 id="分隔链表"><a href="#分隔链表" class="headerlink" title="分隔链表"></a>分隔链表</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给你一个链表的头节点 `head` 和一个特定值 `x` ，请你对链表进行分隔，使得所有 **小于** `x` 的节点都出现在 **大于或等于** `x` 的节点之前。</span><br><span class="line"></span><br><span class="line">你应当 **保留** 两个分区中每个节点的初始相对位置</span><br></pre></td></tr></table></figure>

<p>新建两个链表分别用于存储两部分，因为在遍历的时候往下一个节点走，所以需要建立两个虚拟头节点；另外不要忘记给尾巴的下一个节点赋空值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        ListNode *smlDummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>), *bigDummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode *sml = smlDummy, *big = bigDummy;</span><br><span class="line"></span><br><span class="line">        ListNode* tmp=head;</span><br><span class="line">        <span class="keyword">while</span>(tmp)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp-&gt;val&lt;x)&#123;</span><br><span class="line">                sml-&gt;next=tmp;</span><br><span class="line">                sml=sml-&gt;next;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                big-&gt;next=tmp;</span><br><span class="line">                big=big-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp=tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        sml-&gt;next=bigDummy-&gt;next;</span><br><span class="line">        big-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> smlDummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h2><p>快慢指针</p>
<ol>
<li><p>快指针比慢指针步速两倍，有环必相遇，且相遇时<br>$$<br>f&#x3D;2s&#x3D;s+nb;<br>$$</p>
</li>
<li></li>
<li><p>环入口的位置是<br>$$<br>a+nb<br>$$ {1}<br>另快指针重回头节点，快慢相遇时满足<br>$$<br>x&#x3D;x+nb<br>$$ {2}<br>即得到入口位置 n始终是同一个值</p>
</li>
</ol>
<p>错误：</p>
<p>1. </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ListNode* fast，slow;</span><br><span class="line">        fast=head;</span><br><span class="line">        slow=head;</span><br></pre></td></tr></table></figure>

<p>这样写默认slow是一个结构体不是指针</p>
<ol start="2">
<li>对于尾部节点指向头节点的环链表测试错误：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(slow==fast)  <span class="keyword">return</span> fast;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>换成这样写就对了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(slow==fast)  <span class="keyword">return</span> fast;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="反转指定区间内的链表"><a href="#反转指定区间内的链表" class="headerlink" title="反转指定区间内的链表"></a>反转指定区间内的链表</h2><p>主要思路是借鉴之前的反转链表，不用另外申请空间。</p>
<p>主要的问题在于链表它只能通过遍历去查询，所以我们说在遍历的时候需要记录，而且它是往后的，所以我们需要记录总共四个节点。</p>
<p>错误1：</p>
<p>单个链表由于没有设置虚拟头节点，begin的下一个为空赋值给leftNode，出现访问空指针的错误</p>
<p>错误2：</p>
<p>返回的时候不是返回head。而是返回虚拟头节点的next。因为头节点指的始终是固定的值。</p>
<h2 id="深层拷贝随机链表"><a href="#深层拷贝随机链表" class="headerlink" title="深层拷贝随机链表"></a>深层拷贝随机链表</h2><p>在C++中，深拷贝一个链表意味着创建一个新的链表，其中包含与原始链表相同的节点值，但是内存地址是不同的。这样可以确保对其中一个链表的修改不会影响到另一个链表。以下是深拷贝链表的一般步骤：</p>
<ol>
<li>创建一个新的链表头节点，以及一个当前节点指针来跟踪新链表的尾部。</li>
<li>遍历原始链表，对每个节点执行以下操作： a. 创建一个新节点，将原始节点的值复制到新节点。 b. 将新节点链接到新链表的尾部，并将当前节点指针更新为新节点。</li>
<li>返回新链表的头节点。</li>
</ol>
<p>一开始的想法是先深层拷贝所有的next值以及value值，然后再去重新遍历，去设置它的random值。但是实现的时候发现难点在于它从第一个节点开始往后设置random值的时候，要想找到对应的新的节点，就需要去再从头遍历，这样时间代价会很大。</p>
<p>使用<code>hashmap</code></p>
<p>第一遍遍历用原链表节点做键，新建链表节点为值</p>
<p>第二遍遍历hash查找<code>O1</code>，通过哈希表查找对应的新链表节点，并设置其 next 和 random 指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(head==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">       &#125;</span><br><span class="line">           </span><br><span class="line">       std::unordered_map&lt;Node*,Node*&gt;map;</span><br><span class="line"></span><br><span class="line">       Node* cur=head;</span><br><span class="line">       <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">           map[cur]=<span class="keyword">new</span> <span class="built_in">Node</span>(cur-&gt;val);</span><br><span class="line">           cur=cur-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">       cur=head;</span><br><span class="line">       <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">           map[cur]-&gt;next=map[cur-&gt;next];</span><br><span class="line">           map[cur]-&gt;random=map[cur-&gt;random];</span><br><span class="line">           cur=cur-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> map[head];</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表、栈、队列</category>
      </categories>
      <tags>
        <tag>秋招</tag>
      </tags>
  </entry>
  <entry>
    <title>栈</title>
    <url>/2023/08/15/20-30-49/</url>
    <content><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ul>
<li><p>C++中stack 是容器么？</p>
<p>不是容器，是对底层容器的封装</p>
</li>
<li><p>我们使用的stack是属于哪个版本的STL？ </p>
<p>HP、PJ（也就是VS采用的版本）、SGI（开源，GCC，可读性高）</p>
</li>
<li><p>我们使用的STL中stack是如何实现的？ </p>
<p>默认基于deque</p>
</li>
<li><p>stack 提供迭代器来遍历stack空间么？</p>
<p>因为栈是一种后进先出（LIFO）的数据结构，栈的主要操作是在顶部进行插入和删除操作。栈通常不需要遍历操作，因此标准库没有为 <code>std::stack</code> 提供迭代器。</p>
</li>
</ul>
<h2 id="有效括号"><a href="#有效括号" class="headerlink" title="有效括号"></a>有效括号</h2><p><a href="https://leetcode.cn/problems/valid-parentheses/description/">20. 有效的括号 - 力扣（LeetCode）</a></p>
<p>解法：括号匹配问题，典型的栈</p>
<p>利用<code>hashmap</code>把字符转成对应的数字；</p>
<p><strong>for(char c:s)</strong>:这是 C++11 引入的一种新的循环语法，称为范围基础循环（Range-Based For Loop）。这个语法可以用来遍历容器中的元素，包括字符串。</p>
<p>在C++中，<strong>用大括号 <code>&#123;&#125;</code> 初始化</strong>一个 <code>std::unordered_map</code>（或其他容器）是一种用于初始化的标准方式，这是 C++11 引入的统一的初始化语法。使用大括号的初始化语法在语法上更加一致，更容易阅读和理解，并且可以减少一些初始化问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; dict&#123;</span><br><span class="line">        &#123;<span class="string">&#x27;(&#x27;</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;&#123;&#x27;</span>,<span class="number">2</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;[&#x27;</span>,<span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;)&#x27;</span>,<span class="number">4</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;&#125;&#x27;</span>,<span class="number">5</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;]&#x27;</span>,<span class="number">6</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">   stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c:s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dict[c]&lt;<span class="number">4</span>)</span><br><span class="line">            st.<span class="built_in">push</span>(dict[c]);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(!st.<span class="built_in">empty</span>()&amp;&amp;st.<span class="built_in">top</span>()==dict[c]<span class="number">-3</span>)</span><br><span class="line">            st.<span class="built_in">pop</span>(); </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(st.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span>    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基本计算器"><a href="#基本计算器" class="headerlink" title="基本计算器"></a>基本计算器</h2><p><a href="https://leetcode.cn/problems/basic-calculator/">224. 基本计算器 - 力扣（LeetCode）</a></p>
<h3 id="基础知识-1"><a href="#基础知识-1" class="headerlink" title="基础知识"></a>基础知识</h3><ol>
<li><p>string下的find函数</p>
</li>
<li><p>replace函数:在调用replace函数之后再计算长度不然违法</p>
</li>
<li><p>引用传递<code>void replace(string&amp; s)与void repalceSpace(string s)有什么区别</code></p>
</li>
<li><p>为什么上面那段计算器代码，在执行完循环之后栈内还会有剩余呢？你能举个例子吗</p>
<p>考虑表达式 <code>3 + 4 - (2 + 1)</code>：</p>
<ol>
<li>在循环处理数字和操作符时，<code>3</code> 和 <code>+</code> 会被压入对应的栈。</li>
<li>接着处理 <code>4 -</code>，这里 <code>-</code> 会被压入栈。</li>
<li>遇到左括号 <code>(2 + 1)</code>，将左括号 <code>(</code> 压入栈。</li>
<li>在处理 <code>(2 + 1)</code> 时，数字 <code>2</code>、<code>+</code> 和 <code>1</code> 会被压入对应的栈。</li>
<li>遇到右括号 <code>)</code>，这时开始计算 <code>2 + 1</code> 并将结果 <code>3</code> 压入栈。</li>
<li>循环结束后，栈内情况为：<code>3</code>、<code>+</code>、<code>3</code>、<code>-</code>。最后一个操作符 <code>-</code> 没有被处理。</li>
</ol>
<p>在这个例子中，栈内剩余元素是因为循环结束时最后一个操作符 <code>-</code> 没有机会被处理，整个表达式的计算还未完成。通常，为了确保栈内不会有剩余元素，应该在循环结束后继续处理栈内剩余的操作符，直到栈为空或者遇到左括号。这样可以确保整个表达式的计算得到正确结果。</p>
</li>
</ol>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>利用双栈处理，符号栈和数字栈</li>
<li>先往数字栈中压入0防止开始时负号</li>
<li>去掉原有字符串中的所有空格，记得去掉空格之后再计算长度</li>
<li>对于不同字符处理<ol>
<li><code>(</code>直接压栈</li>
<li><code>)</code>开始处理ops栈内压入符号，栈不为空时除<code>(</code>外进行计算，遇到<code>(</code>进行pop并跳出循环</li>
<li>数字进行读入连续数字**<code>isdigit</code>**</li>
<li>操作符：因为去掉了空格可能出现连续操作符的现象，在数字栈中压入0方便操作；每次压入新符号之前先把能算的都算了直到遇到<code>(</code>或者栈为空</li>
</ol>
</li>
<li>对栈内所有字符进行处理</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">replaceSpace</span><span class="params">(string&amp; s)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> pos=s.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(pos!=<span class="number">-1</span>)&#123;</span><br><span class="line">            s.<span class="built_in">replace</span>(pos,<span class="number">1</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">            pos=s.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">calc</span><span class="params">(stack&lt;<span class="type">int</span>&gt;&amp;nums,stack&lt;<span class="type">char</span>&gt;&amp;ops)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt; <span class="number">2</span> || ops.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> b=nums.<span class="built_in">top</span>();</span><br><span class="line">        nums.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> a=nums.<span class="built_in">top</span>();</span><br><span class="line">        nums.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">char</span> op=ops.<span class="built_in">top</span>();</span><br><span class="line">        ops.<span class="built_in">pop</span>();</span><br><span class="line">        nums.<span class="built_in">push</span>(op==<span class="string">&#x27;+&#x27;</span>?a+b:a-b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; ops;</span><br><span class="line">        </span><br><span class="line">        nums.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">replaceSpace</span>(s);</span><br><span class="line">        <span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">char</span> c=s[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                ops.<span class="built_in">push</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">//这个逻辑是有问题的因为对（也要进行处理进行抛出</span></span><br><span class="line">                <span class="comment">// while(ops.top()!=&#x27;(&#x27;)&#123;</span></span><br><span class="line">                <span class="comment">//     cal(nums,ops);</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">                <span class="keyword">while</span>(!ops.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    <span class="type">char</span> op=ops.<span class="built_in">top</span>();</span><br><span class="line">                    <span class="keyword">if</span>(op!=<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                        <span class="built_in">calc</span>(nums,ops);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        ops.<span class="built_in">pop</span>();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">isdigit</span>(c))&#123;</span><br><span class="line">                    <span class="type">int</span> j=i;</span><br><span class="line">                    <span class="type">int</span> cur_num=<span class="number">0</span>;</span><br><span class="line">                    <span class="comment">// for(j=i;isdigit(s[j])&amp;&amp;j&lt;n;j++)&#123;</span></span><br><span class="line">                    <span class="comment">//     cur_num=cur_num*10+(s[j]-&#x27;0&#x27;);</span></span><br><span class="line">                    <span class="comment">// &#125;</span></span><br><span class="line">                     <span class="keyword">while</span>(j &lt;n &amp;&amp; <span class="built_in">isdigit</span>(s[j]))</span><br><span class="line">                        cur_num = cur_num*<span class="number">10</span> + (s[j++] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                    nums.<span class="built_in">push</span>(cur_num);</span><br><span class="line">                    i=j<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (s[i - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span> || s[i - <span class="number">1</span>] == <span class="string">&#x27;+&#x27;</span> || s[i - <span class="number">1</span>] == <span class="string">&#x27;-&#x27;</span>))&#123;</span><br><span class="line">                        nums.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span>(!ops.<span class="built_in">empty</span>()&amp;&amp;ops.<span class="built_in">top</span>()!=<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                        <span class="built_in">calc</span>(nums,ops);</span><br><span class="line">                    &#125;</span><br><span class="line">                    ops.<span class="built_in">push</span>(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!ops.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="built_in">calc</span>(nums,ops);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a>最小栈</h2><p><a href="https://leetcode.cn/problems/min-stack/">155. 最小栈 - 力扣（LeetCode）</a></p>
<h3 id="手动实现栈"><a href="#手动实现栈" class="headerlink" title="手动实现栈"></a>手动实现栈</h3><ol>
<li>借助<code>vector</code><ol>
<li><strong><code>std::vector&lt;int&gt; data;</code></strong></li>
<li><strong><code>data.push_back(value)</code> <code> data.pop_back();</code> <code>data.back();</code></strong></li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntStack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 将整数压入栈顶</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        data.<span class="built_in">push_back</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 弹出栈顶的整数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!data.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            data.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取栈顶的整数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!data.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> data.<span class="built_in">back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里可以根据需求抛出异常或返回默认值</span></span><br><span class="line">        <span class="comment">// 在这里，我们返回一个特殊值 -1 表示栈为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查栈是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IntStack stack;</span><br><span class="line"></span><br><span class="line">    stack.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">    stack.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">    stack.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Top: &quot;</span> &lt;&lt; stack.<span class="built_in">top</span>() &lt;&lt; std::endl; <span class="comment">// 输出 3</span></span><br><span class="line"></span><br><span class="line">    stack.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Top after pop: &quot;</span> &lt;&lt; stack.<span class="built_in">top</span>() &lt;&lt; std::endl; <span class="comment">// 输出 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        stack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Top after popping all elements: &quot;</span> &lt;&lt; stack.<span class="built_in">top</span>() &lt;&lt; std::endl; <span class="comment">// 输出 -1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ol start="2">
<li>借助动态数组</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntStack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *data; <span class="comment">// 用指针存储动态数组</span></span><br><span class="line">    <span class="type">int</span> capacity; <span class="comment">// 动态数组的容量</span></span><br><span class="line">    <span class="type">int</span> topIndex; <span class="comment">// 标记栈顶元素的索引</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">IntStack</span>() : <span class="built_in">capacity</span>(<span class="number">10</span>), <span class="built_in">topIndex</span>(<span class="number">-1</span>) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">int</span>[capacity]; <span class="comment">// 初始化动态数组</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">IntStack</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data; <span class="comment">// 析构函数中释放内存</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将整数压入栈顶</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (topIndex &lt; capacity - <span class="number">1</span>) &#123;</span><br><span class="line">            topIndex++;</span><br><span class="line">            data[topIndex] = value;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 动态增加容量</span></span><br><span class="line">            <span class="type">int</span> newCapacity = capacity * <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> *newData = <span class="keyword">new</span> <span class="type">int</span>[newCapacity];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line">                newData[i] = data[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span>[] data;</span><br><span class="line">            data = newData;</span><br><span class="line">            capacity = newCapacity;</span><br><span class="line"></span><br><span class="line">            topIndex++;</span><br><span class="line">            data[topIndex] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 弹出栈顶的整数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (topIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            topIndex--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Stack is empty&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取栈顶的整数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (topIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> data[topIndex];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里可以根据需求抛出异常或返回默认值</span></span><br><span class="line">        <span class="comment">// 在这里，我们返回一个特殊值 -1 表示栈为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查栈是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> topIndex == <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IntStack stack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        stack.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; stack.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        stack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="不使用辅助栈"><a href="#不使用辅助栈" class="headerlink" title="不使用辅助栈"></a>不使用辅助栈</h3><p><a href="https://leetcode.cn/problems/validate-stack-sequences/">946. 验证栈序列 - 力扣（LeetCode）</a></p>
<p>通过差值来存储元素</p>
<p>入栈：空：push0,最小值即当前值；或不空：比较最小值与当前值，存储差值并更新最小值</p>
<p>栈顶：通过栈顶差值，小于0说明当前栈顶是最小值返回最小值即可；大于0返回<code>min_value + diff</code></p>
<p>出栈：出栈要维护最小值，栈顶差值大于0最小值不变，小于0栈顶差值表示的是当前最小值与pop之后的最小值的差值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; stack;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> min;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MinStack</span>() :<span class="built_in">min</span>(<span class="number">-1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">long</span> <span class="type">long</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            stack.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">            min = val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> diff = val - min;</span><br><span class="line">            stack.<span class="built_in">push_back</span>(diff);</span><br><span class="line">            min = (diff &gt; <span class="number">0</span> ? min : val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> diff = stack.<span class="built_in">back</span>();</span><br><span class="line">            stack.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">if</span> (diff &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                min = min - diff;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> diff = stack.<span class="built_in">back</span>();</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> top;</span><br><span class="line">            top = (diff &gt; <span class="number">0</span> ? diff + min : min);</span><br><span class="line">            <span class="keyword">return</span> top;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (stack.<span class="built_in">empty</span>() ? <span class="number">-1</span> : min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="验证栈序列"><a href="#验证栈序列" class="headerlink" title="验证栈序列"></a>验证栈序列</h2><p><a href="https://leetcode.cn/problems/validate-stack-sequences/">946. 验证栈序列 - 力扣（LeetCode）</a></p>
<h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>如果 pushed 和 popped是有效的栈操作序列，则经过所有的入栈和出栈操作之后，每个元素各入栈和出栈一次，栈为空；</p>
<p>每次将 pushed 的元素入栈之后，如果栈不为空且栈顶元素与 popped的当前元素相同，则将栈顶元素出栈同时遍历数组 popped，直到栈为空或栈顶元素与 popped的当前元素不同。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">validateStackSequences</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; pushed, vector&lt;<span class="type">int</span>&gt;&amp; popped)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stack;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;pushed.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            stack.<span class="built_in">emplace</span>(pushed[i]);</span><br><span class="line">            <span class="keyword">while</span>(!stack.<span class="built_in">empty</span>()&amp;&amp;stack.<span class="built_in">top</span>()==popped[j])&#123;</span><br><span class="line">                stack.<span class="built_in">pop</span>();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a>每日温度</h2><p><a href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度 - 力扣（LeetCode）</a></p>
<h3 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a>思想</h3><p>维护一个递减栈，存放的是索引</p>
<p>遍历整个数组，如果栈不空，且当前数字大于栈顶元素，那么如果直接入栈的话就不是 递减栈 ，所以需要取出栈顶元素，由于当前数字大于栈顶元素的数字，而且一定是第一个大于栈顶元素的数，直接求出下标差就是二者的距离。</p>
<p>继续看新的栈顶元素，直到当前数字小于等于栈顶元素停止，然后将数字入栈，这样就可以一直保持递减栈，且每个数字和第一个大于它的数的距离也可以算出来。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>返回一个栈，返回栈的索引遍历的时候通过递减栈顶元素得知，不是顺序访问的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; decreStack;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n=temperatures.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!decreStack.<span class="built_in">empty</span>()&amp;&amp;</span><br><span class="line">            temperatures[decreStack.<span class="built_in">top</span>()]&lt;temperatures[i])&#123;</span><br><span class="line">                <span class="type">int</span> t=decreStack.<span class="built_in">top</span>();</span><br><span class="line">                decreStack.<span class="built_in">pop</span>();</span><br><span class="line">                res[t]=i-t;</span><br><span class="line">            &#125;</span><br><span class="line">            decreStack.<span class="built_in">push</span>(i);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h2><p><a href="https://leetcode.cn/problems/trapping-rain-water/description/">42. 接雨水 - 力扣（LeetCode）</a></p>
<h3 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h3><p>单调栈，和上一个差不多问题在于怎么计算，上一个是利用了遍历到的i直接记录到数组当中；这个题要高（pop之后的顶与当前i）宽（下标差值)；因为pop之后用到top需要判断一下当前栈是否为空，空说明之前的都算完了，i作为第一个重新压入就可以</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stack;</span><br><span class="line">        <span class="type">int</span> n=height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.<span class="built_in">empty</span>()&amp;&amp;height[stack.<span class="built_in">top</span>()]&lt;height[i])&#123;</span><br><span class="line">                <span class="type">int</span> d=stack.<span class="built_in">top</span>();</span><br><span class="line">                stack.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(stack.<span class="built_in">empty</span>())</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="type">int</span> l=stack.<span class="built_in">top</span>();</span><br><span class="line">                <span class="type">int</span> r=i;</span><br><span class="line">                <span class="type">int</span> h=<span class="built_in">min</span>(height[l],height[r])-height[d];</span><br><span class="line">                ans+=(r-l<span class="number">-1</span>)*h;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            stack.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表、栈、队列</category>
      </categories>
      <tags>
        <tag>秋招</tag>
      </tags>
  </entry>
  <entry>
    <title>队列</title>
    <url>/2023/08/16/22-00-00/</url>
    <content><![CDATA[<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="用双栈实现队列"><a href="#用双栈实现队列" class="headerlink" title="用双栈实现队列"></a>用双栈实现队列</h2><h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><p>不管是容器还是栈，pop都没有返回值</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ol>
<li>一个栈用于中转</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stackA,stackB;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        stackA.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=stackA.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> a=stackA.<span class="built_in">top</span>();</span><br><span class="line">            stackA.<span class="built_in">pop</span>();</span><br><span class="line">            stackB.<span class="built_in">push</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> top=stackA.<span class="built_in">top</span>();</span><br><span class="line">        stackA.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> a=stackB.<span class="built_in">top</span>();</span><br><span class="line">            stackB.<span class="built_in">pop</span>();</span><br><span class="line">            stackA.<span class="built_in">push</span>(a);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> top;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=stackA.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> a=stackA.<span class="built_in">top</span>();</span><br><span class="line">            stackA.<span class="built_in">pop</span>();</span><br><span class="line">            stackB.<span class="built_in">push</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> top=stackB.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> a=stackB.<span class="built_in">top</span>();</span><br><span class="line">            stackB.<span class="built_in">pop</span>();</span><br><span class="line">            stackA.<span class="built_in">push</span>(a);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> top;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stackA.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>两个分别只做输入栈和输出栈</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; inStack,outStack;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">in2out</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!inStack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            outStack.<span class="built_in">push</span>(inStack.<span class="built_in">top</span>());</span><br><span class="line">            inStack.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        inStack.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(outStack.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="built_in">in2out</span>();</span><br><span class="line">        <span class="type">int</span> top=outStack.<span class="built_in">top</span>();</span><br><span class="line">        outStack.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> top;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(outStack.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="built_in">in2out</span>();</span><br><span class="line">        <span class="keyword">return</span> outStack.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inStack.<span class="built_in">empty</span>()&amp;&amp;outStack.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>回忆 最小栈 ，其使用 单调栈 实现了随意入栈、出栈情况下的 O(1)时间获取 “栈内最小值” 。本题同理，不同点在于 “出栈操作” 删除的是 “列表尾部元素” ，而 “窗口滑动” 删除的是 “列表首部元素” 。</p>
<p>窗口对应的数据结构为 双端队列 ，本题使用 单调队列 即可解决以上问题。遍历数组时，每轮保证单调队列<code> deque</code> ：</p>
<p><code>deque </code>内 仅包含窗口内的元素 ⇒每轮窗口滑动移除了元素 <code>nums[i−1] </code>，需将<code> deque</code>内的对应元素一起删除。<br><code>deque</code> 内的元素 非严格递减 ⇒每轮窗口滑动添加了元素 <code>nums[j+1]</code>，需将 <code>deque</code> 内所有 <code>&lt;nums[j+1]</code>的元素删除。</p>
<h3 id="错误-1"><a href="#错误-1" class="headerlink" title="错误"></a>错误</h3><ol>
<li>怎么形成窗口：i从几开始，从0，i指的是滑动窗口的最右端的值；</li>
<li>需要预先判断是否为空</li>
<li>返回空容器：<code>return&#123;&#125;</code> 表示从函数中返回一个空的初始化列表；容器到底是什么，不能push；</li>
<li>vector有empty有size</li>
<li>返回的数组我没提前声明大小也是可以的因为他是个动态数组，但是如果指定大小就会初始化成0，后续用push_back就会多出一堆0</li>
</ol>
<p>当在C++编程中提到”容器”，通常指的是标准模板库（STL）中提供的各种数据结构。STL容器是用来存储和管理数据的数据结构，它们提供了不同的功能和性能特性，以满足不同的编程需求。</p>
<p>C++中的容器分为以下几类：</p>
<ol>
<li><strong>序列容器（Sequence Containers）</strong>：这些容器按照元素的线性顺序进行存储，可以随时插入、删除元素，并保持它们的顺序。<ul>
<li><code>vector</code>：动态数组，支持快速随机访问和尾部插入&#x2F;删除。</li>
<li><code>deque</code>：双端队列，类似于vector，但支持在头部和尾部插入&#x2F;删除。</li>
<li><code>list</code>：双向链表，支持在任意位置插入&#x2F;删除。</li>
</ul>
</li>
<li><strong>关联容器（Associative Containers）</strong>：这些容器使用键值对的方式存储元素，允许通过键（key）来访问元素，而不是位置。<ul>
<li><code>map</code>：有序键值对集合，每个键关联一个值。</li>
<li><code>set</code>：有序唯一值的集合。</li>
<li><code>multimap</code>：与<code>map</code>类似，但允许多个元素具有相同的键。</li>
<li><code>multiset</code>：与<code>set</code>类似，但允许多个相同的值。</li>
</ul>
</li>
<li><strong>无序关联容器（Unordered Associative Containers）</strong>：类似于关联容器，但不保持元素的顺序，而是根据哈希函数将元素分布在存储桶中。<ul>
<li><code>unordered_map</code>：无序键值对集合。</li>
<li><code>unordered_set</code>：无序唯一值的集合。</li>
<li><code>unordered_multimap</code>：与<code>unordered_map</code>类似，允许多个元素具有相同的键。</li>
<li><code>unordered_multiset</code>：与<code>unordered_set</code>类似，允许多个相同的值。</li>
</ul>
</li>
<li><strong>容器适配器（Container Adapters）</strong>：这些容器提供了不同的接口，使得其他容器的功能得以限制或扩展。<ul>
<li><code>stack</code>：基于<code>deque</code>或<code>vector</code>实现的堆栈（后进先出）。</li>
<li><code>queue</code>：基于<code>deque</code>或<code>list</code>实现的队列（先进先出）。</li>
<li><code>priority_queue</code>：基于<code>vec</code></li>
</ul>
</li>
</ol>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>||k==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; deque;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!deque.<span class="built_in">empty</span>()&amp;&amp;nums[i]&gt;deque.<span class="built_in">back</span>())</span><br><span class="line">                deque.<span class="built_in">pop_back</span>();</span><br><span class="line">            deque.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//res[0]=deque.front();</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(deque.<span class="built_in">front</span>());</span><br><span class="line">        <span class="keyword">for</span>(i=k;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i-k]==deque.<span class="built_in">front</span>())</span><br><span class="line">                deque.<span class="built_in">pop_front</span>();</span><br><span class="line">            <span class="keyword">while</span>(!deque.<span class="built_in">empty</span>()&amp;&amp;nums[i]&gt;deque.<span class="built_in">back</span>())</span><br><span class="line">                deque.<span class="built_in">pop_back</span>();</span><br><span class="line">            deque.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            res.<span class="built_in">push_back</span>(deque.<span class="built_in">front</span>());</span><br><span class="line">            <span class="comment">//res[i-k+1]=deque.front();</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="双端循环队列"><a href="#双端循环队列" class="headerlink" title="双端循环队列"></a>双端循环队列</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>双向链表</p>
<h3 id="错误-2"><a href="#错误-2" class="headerlink" title="错误"></a>错误</h3><ol>
<li>双端队列就用双向链表,所以链表设计的时候要添加只想前面的指针</li>
<li>再删除的时候怎么释放空间</li>
<li>设计构造函数不用每次赋值</li>
<li>怎么删除指针：我的代码问题在于插入的时候根本没有给新指针分配空间</li>
<li>获取值的时候若空返回-1；</li>
<li>访问空指针：删除尾指针的时候不是<code>tail = tail-&gt;next;</code>而是<code>tail = tail-&gt;prev;</code></li>
</ol>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    DListNode* next;</span><br><span class="line">    DListNode* prev;</span><br><span class="line">    <span class="built_in">DListNode</span>(<span class="type">int</span> value) :<span class="built_in">value</span>(value), <span class="built_in">next</span>(<span class="literal">nullptr</span>), <span class="built_in">prev</span>(<span class="literal">nullptr</span>) &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCircularDeque</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    DListNode* head;</span><br><span class="line">    DListNode* tail;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyCircularDeque</span>(<span class="type">int</span> k) :<span class="built_in">head</span>(<span class="literal">nullptr</span>), <span class="built_in">tail</span>(<span class="literal">nullptr</span>), <span class="built_in">size</span>(<span class="number">0</span>), <span class="built_in">capacity</span>(k) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">insertFront</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isFull</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        DListNode* node = <span class="keyword">new</span> <span class="built_in">DListNode</span>(value);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            head = tail = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            head-&gt;prev = node;</span><br><span class="line">            node-&gt;next = head;</span><br><span class="line">            head = node;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">insertLast</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isFull</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        DListNode* node = <span class="keyword">new</span> <span class="built_in">DListNode</span>(value);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            head = tail = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tail-&gt;next = node;</span><br><span class="line">            node-&gt;prev = tail;</span><br><span class="line">            tail = node;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">deleteFront</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        DListNode* node = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (head) &#123;</span><br><span class="line">            head-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> node;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">deleteLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        DListNode* node = tail;</span><br><span class="line">        tail = tail-&gt;prev;</span><br><span class="line">        <span class="keyword">if</span> (tail) &#123;</span><br><span class="line">            tail-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> node;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getFront</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getRear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tail-&gt;value;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == capacity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表、栈、队列</category>
      </categories>
      <tags>
        <tag>秋招</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串</title>
    <url>/2023/08/22/11-32-18/</url>
    <content><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h2><p><a href="https://leetcode.cn/problems/reverse-string/">344. 反转字符串 - 力扣（LeetCode）</a></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>反转链表</p>
<p><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表 - 力扣（LeetCode）</a></p>
<p>反转字符串同样使用两个指针</p>
<p>注意第一个指针什么时候截止</p>
<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ol>
<li><p>reverse</p>
<p><code>reverse</code> 函数可以用于数组（C 风格数组或 C++ 数组）以及各种容器（如 <code>std::vector</code>、<code>std::string</code> 等）。</p>
</li>
<li><p>swap</p>
<p>基本数据类型或者容器类</p>
</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=s.<span class="built_in">size</span>()<span class="number">-1</span>;i&lt;s.<span class="built_in">size</span>()/<span class="number">2</span>;i++,j--)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[i],s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//reverse(s.begin(),s.end());</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="反转字符串2"><a href="#反转字符串2" class="headerlink" title="反转字符串2"></a>反转字符串2</h2><p><a href="https://leetcode.cn/problems/reverse-string-ii/">541. 反转字符串 II - 力扣（LeetCode）</a></p>
<h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><p>在 C++ 中，<code>std::vector</code> 的 <code>begin()</code> <code>end()</code> 迭代器指向的是容器的开始或者尾后位置，而不是第一个或者最后一个元素。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> iter=s.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i+=<span class="number">2</span>*k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i+k<span class="number">-1</span>&lt;s.<span class="built_in">size</span>())</span><br><span class="line">                <span class="built_in">reverse</span>(iter+i,iter+i+k);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">reverse</span>(iter+i,s.<span class="built_in">end</span>());        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol>
<li>之前基本计算器实现过去掉空格<ol>
<li>其实就是调用了replace库函数</li>
<li>值传递还是地址传递</li>
</ol>
</li>
<li>不使用库函数<ol>
<li><strong>数组填充问题</strong>：先扩充大小再<strong>双指针</strong>从后往前填充</li>
</ol>
</li>
</ol>
<h3 id="基础知识-1"><a href="#基础知识-1" class="headerlink" title="基础知识"></a>基础知识</h3><p> s.<strong>resize</strong>(s.size() + count * 2);</p>
<h3 id="错误-1"><a href="#错误-1" class="headerlink" title="错误"></a>错误</h3><p>1. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=sOldSize<span class="number">-1</span>,<span class="type">int</span> j=sNewSize<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--,j--)</span><br></pre></td></tr></table></figure>

<p>修正为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(int i=sOldSize-1,j=sNewSize-1;i&gt;=0;i--,j--)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>count初始化；</li>
<li>两个指针的衰减速度不一样</li>
<li>什么时候终止：<ol>
<li>旧指针&gt;&#x3D;0也可以</li>
<li>新指针&gt;旧指针可能更快一点</li>
</ol>
</li>
</ol>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> pos = s.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">        s.<span class="built_in">replace</span>(pos, <span class="number">1</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        pos = s.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sOldSize=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> i:s)</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                count++;</span><br><span class="line">        s.<span class="built_in">resize</span>(s.<span class="built_in">size</span>() + count * <span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> sNewSize = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=sOldSize<span class="number">-1</span>,j=sNewSize<span class="number">-1</span>;j&gt;i;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]!=<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                s[j]=s[i];</span><br><span class="line">                j--;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                s[j]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                s[j<span class="number">-1</span>]=<span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                s[j<span class="number">-2</span>]=<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                j=j<span class="number">-3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="反转单词"><a href="#反转单词" class="headerlink" title="反转单词"></a>反转单词</h2><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词 - 力扣（LeetCode）</a></p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ul>
<li>移除多余空格<ul>
<li>原地修改双指针</li>
</ul>
</li>
<li>将整个字符串反转</li>
<li>将每个单词反转</li>
</ul>
<h3 id="错误-2"><a href="#错误-2" class="headerlink" title="错误"></a>错误</h3><ol>
<li><code>if(s[i]==&#39; &#39;)</code>修改成<code>if(s[i]==&#39; &#39;|| i==s.size())</code>：在最后一个单词不碰到空格而是<code>i</code>达到最大值，另外对于<code>i</code>的判断也要允许等于<code>s.size()</code></li>
<li>判断老是整成等于号</li>
</ol>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeExtraSpaces</span><span class="params">(string&amp; s)</span> </span>&#123;<span class="comment">//去除所有空格并在相邻单词之间添加空格, 快慢指针。</span></span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;   <span class="comment">//整体思想参考https://programmercarl.com/0027.移除元素.html</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123; <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">//遇到非空格就处理，即删除所有空格。</span></span><br><span class="line">                <span class="keyword">if</span> (slow != <span class="number">0</span>) s[slow++] = <span class="string">&#x27; &#x27;</span>; <span class="comment">//手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。</span></span><br><span class="line">                <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">//补上该单词，遇到空格说明单词结束。</span></span><br><span class="line">                    s[slow++] = s[i++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">resize</span>(slow); <span class="comment">//slow的大小即为去除多余空格后的大小。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(string&amp; s, <span class="type">int</span> start, <span class="type">int</span> end)</span></span>&#123; <span class="comment">//翻转，区间写法：左闭右闭 []</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[i], s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">removeExtraSpaces</span>(s);</span><br><span class="line">        <span class="built_in">reverse</span>(s, <span class="number">0</span>, s.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27; &#x27;</span>|| i==s.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s,start,i<span class="number">-1</span>);</span><br><span class="line">                start=i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="左旋字符串"><a href="#左旋字符串" class="headerlink" title="左旋字符串"></a>左旋字符串</h2><p><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指 Offer 58 - II. 左旋转字符串 - 力扣（LeetCode）</a></p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>整体反转+局部反转</p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseLeftWords</span><span class="params">(string s, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">begin</span>()+size-n);</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>()+size-n,s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="实现strSTR"><a href="#实现strSTR" class="headerlink" title="实现strSTR"></a>实现<code>strSTR</code></h2><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p><strong>在一个串中查找是否出现过另一个串，这是KMP的看家本领</strong></p>
<p><code>KMP</code>算法</p>
<ol>
<li><p>为什么在s[i]!&#x3D;s[j]时要 j&#x3D;next[j-1]</p>
<p>在 <code>j</code> 处的字符与 <code>i</code> 处的字符不匹配，希望寻找一个更短的相等前缀后缀对来尝试匹配</p>
<p>最长相等前后缀的最长相等前后缀</p>
</li>
<li><p>KMP的主要思想是<strong>当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。</strong></p>
<p>前缀表的任务是当前位置匹配失败，找到之前已经匹配上的位置，再重新匹配，此也意味着在某个字符失配时，前缀表会告诉你下一步匹配中，模式串应该跳到哪个位置</p>
</li>
</ol>
<h3 id="错误-3"><a href="#错误-3" class="headerlink" title="错误"></a>错误</h3><ol>
<li><p>为什么while和if不能调换前后位置</p>
<p>1211212 i指向最后一个2，j指向3–j指向1，这个时候需要判断相等。退出循环也有可能是因为找到了相等。</p>
</li>
</ol>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span>* next,string&amp; s)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        next[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(s[i]!=s[j] &amp;&amp; j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                j=next[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==s[j])</span><br><span class="line">                j++;</span><br><span class="line">            </span><br><span class="line">            next[i]=j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> next[needle.<span class="built_in">size</span>()];</span><br><span class="line">        <span class="built_in">getNext</span>(next,needle);</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;haystack.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(haystack[i]!=needle[j] &amp;&amp; j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                j=next[j<span class="number">-1</span>];</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">if</span>(haystack[i]==needle[j])</span><br><span class="line">                j++;</span><br><span class="line">            <span class="keyword">if</span>(j==needle.<span class="built_in">size</span>())</span><br><span class="line">                <span class="keyword">return</span> i-needle.<span class="built_in">size</span>()+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="重复的子字符串"><a href="#重复的子字符串" class="headerlink" title="重复的子字符串"></a>重复的子字符串</h2><p><a href="https://leetcode.cn/problems/repeated-substring-pattern/">459. 重复的子字符串 - 力扣（LeetCode）</a></p>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>对于由重复字符串组成的字符串，它的最长公共前缀如果说是<code>MX</code>的话，它的长度是<code>NX</code>，其中<code>X</code>是它的子串长度；<code>NX</code>减去<code>MX</code>得到子串的长度，<code>MX</code>可以通过前缀表得知。</p>
<h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span>* next,string s)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        next[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(s[i]!=s[j] &amp;&amp; j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                j=next[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==s[j])</span><br><span class="line">                j++;</span><br><span class="line">            next[i]=j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> next[len];</span><br><span class="line">        <span class="built_in">getNext</span>(next,s);</span><br><span class="line">        <span class="keyword">if</span>(len%(len-next[len<span class="number">-1</span>])==<span class="number">0</span> &amp;&amp; next[len<span class="number">-1</span>]!=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>LeetCode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>秋招</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希表</title>
    <url>/2023/08/22/11-32-32/</url>
    <content><![CDATA[<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a>有效的字母异位词</h2><p><a href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词 - 力扣（LeetCode）</a></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>哈希表，如果是简单的26个英文字母直接设置一个数组就可以；但如果是<code>Uniode</code>,<code>Unicode</code> 中可能存在一个字符对应多个字节的问题,用哈希表维护对应字符的频次即可，键为char，值为出现次数。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">length</span>()!=t.<span class="built_in">length</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">table</span><span class="params">(<span class="number">26</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:s)&#123;</span><br><span class="line">            table[c-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:t)&#123;</span><br><span class="line">            table[c-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="keyword">if</span>(table[c-<span class="string">&#x27;a&#x27;</span>]&lt;<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h2><p><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">349. 两个数组的交集 - 力扣（LeetCode）</a></p>
<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ol>
<li><p><code>unordered_set</code>，<code>unordered_map</code>有什么区别吗</p>
<p><code>unordered_set</code>存储唯一值，<code>unordered_map</code>存储键值对</p>
</li>
</ol>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>哈希表，采用<code>unordered_set</code></p>
<h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><ol>
<li><p><code>expected &#39;(&#39; for function-style cast or type construction</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt; <span class="built_in">result</span>(result.<span class="built_in">begin</span>(),result.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<p>给结果加个括号</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        std::unordered_set&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="function">std::unordered_set&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(nums1.begin(),nums1.end())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> n:nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums.<span class="built_in">find</span>(n)!=nums.<span class="built_in">end</span>())</span><br><span class="line">                result.<span class="built_in">insert</span>(n);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a>快乐数</h2><p><a href="https://leetcode.cn/problems/happy-number/">202. 快乐数 - 力扣（LeetCode）</a></p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>一开始以为是数学问题，但是题目有暗示要么这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1</p>
<p>如何终止无限循环：找到一样的数字就立马返回</p>
<h3 id="错误-1"><a href="#错误-1" class="headerlink" title="错误"></a>错误</h3><ol>
<li>要循环计算n，设计一个<code>while(1)</code>；</li>
</ol>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            sum+=(n%<span class="number">10</span>) * (n%<span class="number">10</span>);</span><br><span class="line">            n=n/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; sumSet;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> sum=<span class="built_in">getSum</span>(n);</span><br><span class="line">            <span class="keyword">if</span>(sum==<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(sumSet.<span class="built_in">find</span>(sum)!=sumSet.<span class="built_in">end</span>())</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    sumSet.<span class="built_in">insert</span>(sum);</span><br><span class="line">                      </span><br><span class="line">            &#125;</span><br><span class="line">            n=sum;  </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><p><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和 - 力扣（LeetCode）</a></p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol>
<li><strong>不找和，找另外一个加数；</strong></li>
</ol>
<ul>
<li><p>为什么会想到用哈希表</p>
<p>查询一个元素是否出现过，或者一个元素是否在集合里的时候</p>
</li>
<li><p>哈希表为什么用map</p>
<p>set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。</p>
</li>
<li><p>map中的key和value用来存什么的</p>
<p>可以用key保存数值，用value在保存数值所在的下标</p>
</li>
</ul>
<h3 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h3><ol>
<li><p><strong>如何返回一个vector</strong></p>
<p>用{}括起来</p>
</li>
<li><p><strong>怎么插入键值对</strong></p>
<p>pair关键字</p>
</li>
<li><p><strong>find</strong></p>
<p>find返回的是一个键值对pair</p>
</li>
</ol>
<h3 id="错误-2"><a href="#错误-2" class="headerlink" title="错误"></a>错误</h3><ol>
<li><p><code>for(int i:nums)</code>代表的是数组里面的内容，而不是下标</p>
</li>
<li><p><strong>如何返回一个vector</strong></p>
<p>用{}括起来，不是（）；</p>
</li>
</ol>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> iter=map.<span class="built_in">find</span>(target-nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(iter!=map.<span class="built_in">end</span>())</span><br><span class="line">                <span class="keyword">return</span> &#123;iter-&gt;second,i&#125;;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                map.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;(nums[i],i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="三数相加"><a href="#三数相加" class="headerlink" title="三数相加"></a>三数相加</h2><p><a href="https://leetcode.cn/problems/3sum/">15. 三数之和 - 力扣（LeetCode）</a></p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><ol>
<li>利用两数之和，由于题目要求不能是重复的三元组，去重比较麻烦</li>
<li>双指针，左右指针收缩</li>
</ol>
<h3 id="错误-3"><a href="#错误-3" class="headerlink" title="错误"></a>错误</h3><p>在找到答案之后，left和right需要继续移动；</p>
<p>判断重复时也需要右大于左；</p>
<p>去重逻辑应该放在找到一个三元组之后，左右指针移动之前，对b 和 c去重，</p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i]==nums[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> left=i+<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> right=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(right&gt;left)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[left]+nums[right]&lt;<span class="number">0</span>)    left++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[i]+nums[left]+nums[right]&gt;<span class="number">0</span>)   right--;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums[i],nums[left],nums[right]&#125;);</span><br><span class="line">                    <span class="keyword">while</span>(right&gt;left &amp;&amp; nums[left]==nums[left+<span class="number">1</span>]) left++;</span><br><span class="line">                    <span class="keyword">while</span>(right&gt;left &amp;&amp; nums[right]==nums[right<span class="number">-1</span>]) right--;</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line"></span><br><span class="line">                   </span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h2><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>跟三数之和逻辑一样，外面再套一层就可以了</p>
<p>增加剪枝</p>
<h3 id="错误-4"><a href="#错误-4" class="headerlink" title="错误"></a>错误</h3><ol>
<li>剪枝处理：对于负数，大于target并不行还得大于0</li>
<li>二重剪枝</li>
<li>数字范围</li>
</ol>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;nums.<span class="built_in">size</span>();k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[k]&gt;target &amp;&amp; nums[k] &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(k &gt;<span class="number">0</span> &amp;&amp; nums[k]==nums[k<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=k+<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[k]+nums[i] &gt; target &amp;&amp; nums[k]+nums[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;k+<span class="number">1</span> &amp;&amp; nums[i]==nums[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> left=i+<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> right=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(right&gt;left)&#123;</span><br><span class="line">                <span class="keyword">if</span>((<span class="type">long</span>)nums[k]+nums[i]+nums[left]+nums[right]&lt;target)    left++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>((<span class="type">long</span>)nums[k]+nums[i]+nums[left]+nums[right]&gt;target)   right--;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums[k],nums[i],nums[left],nums[right]&#125;);</span><br><span class="line">                    <span class="keyword">while</span>(right&gt;left &amp;&amp; nums[left]==nums[left+<span class="number">1</span>]) left++;</span><br><span class="line">                    <span class="keyword">while</span>(right&gt;left &amp;&amp; nums[right]==nums[right<span class="number">-1</span>]) right--;</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line"></span><br><span class="line">                   </span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="四数相加2"><a href="#四数相加2" class="headerlink" title="四数相加2"></a>四数相加2</h2><p><a href="https://leetcode.cn/problems/4sum-ii/">454. 四数相加 II - 力扣（LeetCode）</a></p>
<h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>和上一道题不一样，不要求不能重复</p>
<h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> a:nums1)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> b:nums2)&#123;</span><br><span class="line">                map[a+b]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> c:nums3)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> d:nums4)&#123;</span><br><span class="line">                <span class="keyword">if</span>(map.<span class="built_in">find</span>(<span class="number">0</span>-(c+d))!=map.<span class="built_in">end</span>())</span><br><span class="line">                    count+=map[<span class="number">0</span>-(c+d)];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="赎金信"><a href="#赎金信" class="headerlink" title="赎金信"></a>赎金信</h2><h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>和有效的字母异位词思路一样</p>
<p>开始想用set不允许重复，用数组</p>
<h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">table</span><span class="params">(<span class="number">26</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c:magazine)&#123;</span><br><span class="line">            table[c-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:ransomNote)&#123;</span><br><span class="line">            table[c-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="keyword">if</span>(table[c-<span class="string">&#x27;a&#x27;</span>]&lt;<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>LeetCode</category>
        <category>哈希表</category>
      </categories>
      <tags>
        <tag>秋招</tag>
      </tags>
  </entry>
  <entry>
    <title>排序</title>
    <url>/2023/08/23/12-48-23/</url>
    <content><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="最小的k个数"><a href="#最小的k个数" class="headerlink" title="最小的k个数"></a>最小的k个数</h2><p><a href="https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/">剑指 Offer 40. 最小的k个数 - 力扣（LeetCode）</a></p>
<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>堆（Heap）是一种基于完全二叉树结构的数据结构，具有以下特点：</p>
<ol>
<li><strong>堆的性质（最大堆和最小堆）</strong>：堆可以分为最大堆和最小堆两种类型。在最大堆中，父节点的值大于或等于其子节点的值，即堆顶元素是最大的；而在最小堆中，父节点的值小于或等于其子节点的值，即堆顶元素是最小的。这种性质使得堆顶元素具有一定的顺序关系，而子树的结构没有特定的顺序。</li>
<li><strong>堆的结构性质</strong>：堆是一棵完全二叉树，即除了最底层，其他层的节点都是满的，且最底层的节点尽可能地靠左排列。</li>
</ol>
<p>堆通常用于实现优先队列、堆排序等算法，因为它能够在O(logN)的时间内执行插入、删除等操作，使其在动态维护一组元素的过程中非常高效。</p>
<p>堆可以使用数组来实现，其中节点的索引关系满足一定的规则。比如，对于一个索引为i的节点，其父节点的索引是(i-1)&#x2F;2，而左子节点的索引是2<em>i+1，右子节点的索引是2</em>i+2。</p>
<p>堆的操作包括：</p>
<ul>
<li>插入（Insertion）：将一个新元素添加到堆中，然后通过一系列调整操作维持堆的性质。</li>
<li>删除堆顶元素（Deletion）：移除堆顶元素，然后将最后一个元素放到堆顶，再通过一系列调整操作维持堆的性质。</li>
<li>查找堆顶元素（Top）：返回堆顶元素，也就是最大（或最小）元素。</li>
<li>堆化（Heapify）：将一个无序数组转换为堆结构，通常是通过从最后一个非叶节点开始，逐级进行向下调整的过程。</li>
</ul>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><ol>
<li><strong>分割阶段</strong>：选择一个基准元素（通常是数组中的一个元素），将数组分割成两个子数组，一个小于基准元素的子数组，一个大于基准元素的子数组。这个过程被称为分割（Partitioning）。</li>
<li><strong>递归阶段</strong>：对分割后的两个子数组递归地应用快速排序算法，将它们分别排序。</li>
<li><strong>合并阶段</strong>：将排序后的子数组合并起来，就得到了完整的有序数组。</li>
</ol>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="大根堆"><a href="#大根堆" class="headerlink" title="大根堆"></a>大根堆</h4><ol>
<li><p>用大根堆维护前k小值，将前k个元素插入堆中；之后的元素与堆顶比较即可，小即插入；</p>
<ol>
<li><p>C++ 语言中的堆（即优先队列）为大根堆</p>
</li>
<li><p>为什么找出最小的k个数要用大根堆：对于最大队维护维护最小值的情况，如果说新加入一个最小的新数值，对于当前的大根堆来说，顶端值是最大的，所以说我们要把这个最大的扔出去，再把这个最小的加起来。所以说它是可以维护当前最小的值，那么同理对于小根堆维护最大值也是一样的。</p>
</li>
<li><p>对于大根堆插入的时间复杂度：<br>$$<br>O(log⁡k)<br>$$</p>
</li>
</ol>
</li>
</ol>
<h4 id="快速排序-1"><a href="#快速排序-1" class="headerlink" title="快速排序"></a>快速排序</h4><ol>
<li>直接排序</li>
<li>只要求返回最小的 k 个数，对这 k 个数的顺序并没有要求。因此，只需要将数组划分为 <strong>最小的 k个数</strong> 和 <strong>其他数字</strong> 两部分即可；考虑在每次哨兵划分后，判断基准数在数组中的索引是否等于 k，若 true则直接返回此时数组的前 <em>k</em>个数字即可。<ol>
<li>什么时候终止递归：i&#x3D;&#x3D;k</li>
</ol>
</li>
</ol>
<h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><h4 id="用大根堆"><a href="#用大根堆" class="headerlink" title="用大根堆"></a>用大根堆</h4><ol>
<li>如何创建大根堆：priority_queue<int> Q;</li>
<li>vector初始化： vector<int> result**(k,0)**</li>
<li>不是push i插入的是数组值</li>
</ol>
<h4 id="快速排序-2"><a href="#快速排序-2" class="headerlink" title="快速排序"></a>快速排序</h4><ol>
<li><p>左哨兵i挪动的时候是&lt;&#x3D;，而不是&lt;</p>
</li>
<li><p>忘记加终止递归的条件</p>
</li>
<li><p>i和k比较大小之后怎么递归调用：就是右子序列递归的时候，代表第 k+1小的数字在右子数组中，则递归右子数组；</p>
</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="大根堆-1"><a href="#大根堆-1" class="headerlink" title="大根堆"></a>大根堆</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(k,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> n=arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            Q.<span class="built_in">push</span>(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=k;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&lt;Q.<span class="built_in">top</span>())&#123;</span><br><span class="line">                Q.<span class="built_in">pop</span>();</span><br><span class="line">                Q.<span class="built_in">push</span>(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            result[i]=Q.<span class="built_in">top</span>();</span><br><span class="line">            Q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="快速排序-3"><a href="#快速排序-3" class="headerlink" title="快速排序"></a>快速排序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;arr,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> i=l;</span><br><span class="line">        <span class="type">int</span> j=r;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(arr[j]&gt;=arr[l]&amp;&amp;i&lt;j)   j--;</span><br><span class="line">            <span class="keyword">while</span>(arr[i]&lt;=arr[l]&amp;&amp;i&lt;j)   i++;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i],arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(arr[l],arr[i]);</span><br><span class="line">        <span class="built_in">quickSort</span>(arr,l,i<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">quickSort</span>(arr,i+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">quickSort</span>(arr,<span class="number">0</span>,arr.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)    result.<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第二种快排：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;arr,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> i=l;</span><br><span class="line">        <span class="type">int</span> j=r;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(arr[j]&gt;=arr[l]&amp;&amp;i&lt;j)   j--;</span><br><span class="line">            <span class="keyword">while</span>(arr[i]&lt;=arr[l]&amp;&amp;i&lt;j)   i++;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i],arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(arr[l],arr[i]);</span><br><span class="line">        <span class="built_in">quickSort</span>(arr,l,i<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">quickSort</span>(arr,i+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">quickSort</span>(arr,<span class="number">0</span>,arr.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)    result.<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="数据流中位数"><a href="#数据流中位数" class="headerlink" title="数据流中位数"></a>数据流中位数</h2><p>[295. 数据流的中位数 - 力扣（LeetCode）](<a href="https://leetcode.cn/problems/find-median-from-data-stream/">https://leetcode.cn/problems/find-median-from-data-stream/</a></p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>建立一个 小顶堆 AAA 和 大顶堆 BBB ，各保存列表的一半元素，且规定：</p>
<p>​	A保存 <strong>较大</strong> 的一半,B 保存 <strong>较小</strong> 的一半；</p>
<p>设元素总数为 N&#x3D;m+n ，其中 m 和 n分别为 A 和 B中的元素个数，保持m&gt;&#x3D;n</p>
<p>插入的时候，如果说M大于N，那么这个时候新的插入就往B里面去放，但是新插入的这个元素又不一定属于较小的一半，所以说我们需要先把这个数字插入到小根堆当中，再把A的top push进B里面去然后再popA。</p>
<h3 id="基础知识-1"><a href="#基础知识-1" class="headerlink" title="基础知识"></a>基础知识</h3><ol>
<li><p>priority_queue&lt;int, vector<int>, greater<int>&gt; A的第二个参数，第三个参数是什么意思</p>
<ol>
<li><p><strong>第二个参数：底层容器类型</strong></p>
<p><code>priority_queue</code> 的第二个参数指定底层容器的类型。在你的代码中，<code>vector&lt;int&gt;</code> 被用作底层容器，这意味着底层实际上使用了一个 <code>vector</code> 来存储元素。</p>
<p><strong><code>deque</code>（双端队列）</strong>也可以作为 <code>priority_queue</code> 的底层容器</p>
</li>
<li><p><strong>第三个参数：比较函数对象</strong></p>
<p><code>priority_queue</code> 的第三个参数是一个可选参数，用于指定比较函数。比较函数决定了堆中元素的排列顺序，从而影响堆顶元素的选择。</p>
<ul>
<li><code>greater&lt;int&gt;</code>：这是一个函数对象，它定义了一个比较操作，用于将元素按照从小到大的顺序排列。也就是说，堆顶元素将是队列中的最小元素。</li>
<li><code>less&lt;int&gt;</code>：与 <code>greater</code> 相反，它定义了一个比较操作，用于将元素按照从大到小的顺序排列，堆顶元素将是队列中的最大元素。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="错误-1"><a href="#错误-1" class="headerlink" title="错误"></a>错误</h3><ol>
<li>小根堆的默认方式</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt; A;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>size（）</li>
</ol>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt; A;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt;&gt; B;</span><br><span class="line">    <span class="built_in">MedianFinder</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addNum</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A.<span class="built_in">size</span>()!=B.<span class="built_in">size</span>())&#123;</span><br><span class="line">            A.<span class="built_in">push</span>(num);</span><br><span class="line">            B.<span class="built_in">push</span>(A.<span class="built_in">top</span>());</span><br><span class="line">            A.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            B.<span class="built_in">push</span>(num);</span><br><span class="line">            A.<span class="built_in">push</span>(B.<span class="built_in">top</span>());</span><br><span class="line">            B.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (A.<span class="built_in">size</span>()==B.<span class="built_in">size</span>()?(A.<span class="built_in">top</span>()+B.<span class="built_in">top</span>())/<span class="number">2.0</span>:A.<span class="built_in">top</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h2><p><a href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">剑指 Offer 51. 数组中的逆序对 - 力扣（LeetCode）</a></p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p><strong>「归并排序」与「逆序对」是息息相关的</strong></p>
<p>在合并阶段，每当遇到 ij没到头左子数组当前元素 &gt; 右子数组当前元素，意味着 「左子数组当前元素 至 末尾元素」 与 「右子数组当前元素」 构成了若干 「逆序对」 。</p>
<h3 id="错误-2"><a href="#错误-2" class="headerlink" title="错误"></a>错误</h3><ol>
<li><p>是划分结束进行合并吗</p>
<p>是的，划分到长度为1的子数组，然后在合并的过程中计算逆序对的数量并排序</p>
</li>
<li><p>为什么没有另外申请空间存储返回值</p>
<p>就是res返回值</p>
</li>
<li><p>暂存数组 nums 闭区间lr内的元素至辅助数组是什么作用？</p>
<p>排序后的元素可能会覆盖掉原数组中未排序的元素，因此需要一个临时的数组来存储合并过程中的中间结果；</p>
</li>
<li><p>正常的合并是什么样子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (i &lt;= m &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp[i] &lt;= tmp[j]) nums[k++] = tmp[i++];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[k++] = tmp[j++];</span><br><span class="line">                res += m - i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= m) nums[k++] = tmp[i++];</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= r) nums[k++] = tmp[j++];</span><br></pre></td></tr></table></figure>


</li>
<li><p>left和right是左闭右闭</p>
</li>
<li><p>调换顺序的问题： 不知道为什么，{ 233,2000000001,234,2000000006,235,2000000003,236,2000000007,237,2000000002,2000000005,233,233,233,233,233,2000000004 };就是在不越界的情况下先循环填充再重复剩下的，剩下的两个while条件调换是可以的。</p>
</li>
</ol>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reversePairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">mergeSortI</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span>  <span class="title">mergeSortI</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r, vector&lt;<span class="type">int</span>&gt;&amp; tmp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> res=<span class="built_in">mergeSortI</span>(nums, l, m, tmp)+ <span class="built_in">mergeSortI</span>(nums, m + <span class="number">1</span>, r, tmp);</span><br><span class="line">        <span class="type">int</span> k = l;</span><br><span class="line">        <span class="keyword">for</span> (k = l; k &lt;= r; k++) &#123;</span><br><span class="line">            tmp[k] = nums[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i = l, j = m + <span class="number">1</span>;</span><br><span class="line">        k = l;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= m &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp[i] &lt;= tmp[j]) nums[k++] = tmp[i++];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[k++] = tmp[j++];</span><br><span class="line">                res += m - i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= r) nums[k++] = tmp[j++];</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= m) nums[k++] = tmp[i++];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="合并K个升序链表"><a href="#合并K个升序链表" class="headerlink" title="合并K个升序链表"></a>合并K个升序链表</h2><p><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">23. 合并 K 个升序链表 - 力扣（LeetCode）</a></p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol>
<li><p>采用归并排序，需要合并两个链表</p>
<ol>
<li>先合并两个链表</li>
<li>再递归合并</li>
</ol>
</li>
<li><p>优先队列</p>
<ol>
<li>创建优先队列并使用推导指引自定义比较函数与初始元素</li>
</ol>
</li>
</ol>
<h3 id="基础知识-2"><a href="#基础知识-2" class="headerlink" title="基础知识"></a>基础知识</h3><ol>
<li><code>remove_if</code>：这是一个标准库算法，用于在指定范围内移除满足特定条件的元素。它接受三个参数：起始迭代器、终止迭代器和一个谓词（predicate）函数，将满足条件的元素移动到容器的末尾，不过并没有真正删除这些元素，而是将它们移到了末尾，并返回一个新的终止迭代器，指向这些被移动的元素之后的位置。</li>
<li><code>lists.erase(..., lists.end())</code>：最终，使用 <code>erase</code> 函数来删除已经被移动到容器末尾的元素。<code>erase</code> 函数接受一个范围，由两个迭代器指定。</li>
</ol>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><ol>
<li><p>如果采取归并排序的思想要怎么才能确定链表的l和r</p>
<p>传入的是一个链表数组</p>
</li>
<li><p>为甚么要分成三个函数去写</p>
<p>之前的正常归并排序是两个数组：第一，这里是多个；第二，如果是换成合并多个数组也是一样的</p>
</li>
</ol>
<h4 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h4><ol>
<li><p>推导指引</p>
<ol>
<li><code>lists</code> 的作用是为优先队列提供初始元素。</li>
<li>我只知道利用匿名函数可以这么干，但是目前还不是很清楚为什么建立的是小根堆：比较函数的性质：如果 <code>a</code> 的 <code>val</code> 大于 <code>b</code> 的 <code>val</code>，则返回 <code>true</code>，表示 <code>a</code> 应该排在 <code>b</code> 前面</li>
</ol>
</li>
<li><p>怎么从原链表中获取下一个节点放入堆中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">p = p-&gt;next = q.<span class="built_in">top</span>();</span><br><span class="line"><span class="keyword">if</span> (p-&gt;next) q.<span class="built_in">push</span>(p-&gt;next);</span><br></pre></td></tr></table></figure>
</li>
<li><p>小根堆：比较函数 <code>[](auto&amp; a, auto&amp; b) &#123; return a-&gt;val &gt; b-&gt;val; &#125;</code> 表示如果 <code>a-&gt;val</code> 大于 <code>b-&gt;val</code>，则 <code>a</code> 更小</p>
</li>
<li><p>一个节点为空时怎么处理：队列会push他的下一个，当p-&gt;next为空时，队列还不是空，继续进入循环，p-&gt;next赋值为top()</p>
</li>
</ol>
<h3 id="错误-3"><a href="#错误-3" class="headerlink" title="错误"></a>错误</h3><h4 id="归并排序："><a href="#归并排序：" class="headerlink" title="归并排序："></a>归并排序：</h4><ol>
<li>head没初始化</li>
<li>访问空指针：ij不是ab</li>
</ol>
<h4 id="优先队列-1"><a href="#优先队列-1" class="headerlink" title="优先队列"></a>优先队列</h4><ol>
<li>没有将容器中的空节点删除（不删在优先队列初始化的时候会有问题）</li>
<li>匿名函数语句忘记加分号</li>
<li>优先队列为空不用空指针，empty函数</li>
<li>head没初始化，如果new的话还得删除；不如直接head是节点不是指针</li>
</ol>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><h4 id="归并排序-1"><a href="#归并排序-1" class="headerlink" title="归并排序"></a>归并排序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* a, ListNode* b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((!a) || (!b))    <span class="keyword">return</span> a ? a : b;</span><br><span class="line">        ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        ListNode* tail = head;</span><br><span class="line">        ListNode* i = a;</span><br><span class="line">        ListNode* j = b;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (i &amp;&amp; j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i-&gt;val &lt;= j-&gt;val) &#123;</span><br><span class="line">                tail-&gt;next = i;</span><br><span class="line">                i = i-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail-&gt;next = j;</span><br><span class="line">                j = j-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        tail-&gt;next = i ? i : j;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r)    <span class="keyword">return</span> lists[l];</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> m=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mergeTwoLists</span>(<span class="built_in">merge</span>(lists,l,m),<span class="built_in">merge</span>(lists,m+<span class="number">1</span>,r));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(lists,<span class="number">0</span>,lists.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="优先队列-2"><a href="#优先队列-2" class="headerlink" title="优先队列"></a>优先队列</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        lists.<span class="built_in">erase</span>(<span class="built_in">remove_if</span>(lists.<span class="built_in">begin</span>(),</span><br><span class="line">                                lists.<span class="built_in">end</span>(),</span><br><span class="line">                                [](<span class="keyword">auto</span> a)&#123;<span class="keyword">return</span> !a;&#125;),</span><br><span class="line">                              lists.<span class="built_in">end</span>());</span><br><span class="line">        priority_queue q&#123;[](<span class="keyword">auto</span>&amp; a,<span class="keyword">auto</span>&amp; b)&#123;<span class="keyword">return</span> a-&gt;val&gt;b-&gt;val;&#125;,lists&#125;;</span><br><span class="line">        ListNode head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p=&amp;head;!q.<span class="built_in">empty</span>();q.<span class="built_in">pop</span>())&#123;</span><br><span class="line">            p-&gt;next=q.<span class="built_in">top</span>();</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next) q.<span class="built_in">push</span>(p-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h2><p><a href="https://leetcode.cn/problems/merge-sorted-array">力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台</a></p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>直接覆盖原0后快速排序返回</p>
<h3 id="错误-4"><a href="#错误-4" class="headerlink" title="错误"></a>错误</h3><ol>
<li>m，n含义没搞清楚</li>
<li>快速排序不是很熟悉，两个return是递归结束和其他递归返回</li>
</ol>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> i=l;</span><br><span class="line">        <span class="type">int</span> j=r;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[j]&gt;=nums[l]&amp;&amp;i&lt;j) j--;</span><br><span class="line">            <span class="keyword">while</span>(nums[i]&lt;=nums[l]&amp;&amp;i&lt;j) i++;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i],nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[l],nums[i]);</span><br><span class="line">        <span class="built_in">quickSort</span>(nums,l,i<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">quickSort</span>(nums,i+<span class="number">1</span>,r);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                nums1[i+m]=nums2[i];</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="built_in">quickSort</span>(nums1,<span class="number">0</span>,m+n<span class="number">-1</span>);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="颜色分类"><a href="#颜色分类" class="headerlink" title="颜色分类"></a>颜色分类</h2><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><ol>
<li><p>直接先排序（快排）</p>
</li>
<li><p>进阶：快排的空间复杂度和时间复杂度取决于递归的次数</p>
<ol>
<li><p>时间: 最好情况每次递归都平分数组，一共需要递归<br>$$<br>logn<br>$$<br>次，每次需要n时间，复杂度为<br>$$<br>O(n*logn)<br>$$<br>最坏情况每次都把数组分成1和n-1，一共需要递归n次，每次需要n时间，总体复杂度为<br>$$<br>O(n^2)。<br>$$<br>平均总体时间复杂度为<br>$$<br>O(nlogn)<br>$$<br>。</p>
</li>
<li><p>空间: 和时间复杂度相关，每次递归需要的空间是固定的，总体空间复杂度即为递归层数，因此平均&#x2F;最好空间复杂度为<br>$$<br>O(logn)<br>$$<br>最坏空间复杂度为<br>$$<br>O(n)<br>$$</p>
</li>
</ol>
</li>
<li><p>空间复杂度为O(1)也就是说通过一次遍历，把数组分成三个部分</p>
<ol>
<li>需要找出所有的 000 交换至数组的头部，并且找出所有的 222 交换至数组的尾部，一个指针 p2  是从右向左移动的，因此当我们在从左向右遍历整个数组时，如果遍历到的位置超过了p2 ，那么就可以直接停止遍历了。注意碰到2的时候交换过来什么并不知道所以i不能移动。<ol start="2">
<li>同样也是双指针，一定要注意区间的开闭，这里选择左闭右开（01），2选择左开右闭；所以循环遍历到i&lt;&#x3D;p2</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="错误-5"><a href="#错误-5" class="headerlink" title="错误"></a>错误</h3><ol>
<li>区间的定义</li>
<li>交换1的时候为什么可以确定挪动i，因为i左边的不是0就是1，</li>
</ol>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sortColors</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> p0=<span class="number">0</span>,p2=n<span class="number">-1</span>,i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=p2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i],nums[p0]);</span><br><span class="line">                p0++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]==<span class="number">1</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i],nums[p2]);</span><br><span class="line">                p2--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="部分排序"><a href="#部分排序" class="headerlink" title="部分排序"></a>部分排序</h2><p><a href="https://leetcode.cn/problems/sub-sort-lcci/">面试题 16.16. 部分排序 - 力扣（LeetCode）</a></p>
<h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>排序前后的数组对比，从第一个开始不一样的入栈到最后一个不一样的</p>
<h3 id="错误-6"><a href="#错误-6" class="headerlink" title="错误"></a>错误</h3><p>返回错了，题目要求的是下标范围</p>
<h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">subSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; array)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; tmp=array;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(tmp.<span class="built_in">begin</span>(),tmp.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;array.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i]!=tmp[i])    res.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">size</span>()?vector&lt;<span class="type">int</span>&gt;&#123;res[<span class="number">0</span>],res.<span class="built_in">back</span>()&#125;:vector&lt;<span class="type">int</span>&gt; &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="计算右侧小于当前元素的个数"><a href="#计算右侧小于当前元素的个数" class="headerlink" title="计算右侧小于当前元素的个数"></a>计算右侧小于当前元素的个数</h2><p><a href="https://leetcode.cn/problems/count-of-smaller-numbers-after-self/">315. 计算右侧小于当前元素的个数 - 力扣（LeetCode）</a></p>
<h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>类似于逆序对，采用归并排序</p>
<p>流程：归并排序+索引下标+计算返回值</p>
<ol>
<li>需要加入索引下标，在遍历的时候<strong>如何获取当前元素的下标</strong>：比如我们想要排序 5261，在最后一次递归的时候得到2516，存在tmp里而且知道对应的下标。</li>
<li>关于计算是在左归的时候计算还是在右归的时候计算：当前左数 &lt; &#x3D; 右数 , 说明右数已合并的数，都小于该左数；需要统计进去，即 res[indexes[k]] +&#x3D; (j - mid - 1);代码<ol>
<li>有没有可能出现当前左数 &lt; &#x3D; 右数 , 说明右数已合并的数大于该左数的情况：实际上不可能，因为EX:25 36，i指向2，j指向6这种是不可能的，因为在j指向3时i一定会移动</li>
</ol>
</li>
</ol>
<h3 id="错误-7"><a href="#错误-7" class="headerlink" title="错误"></a>错误</h3><ol>
<li><p>[1,0,1,0]不管左归右归都是这个结果</p>
<ol>
<li>debug发现整个nums就不对，整体的逻辑没错，debug<ol>
<li><code>res[nums[i].second] += j - m - 1</code>是不对的，tmp是新复制的数组，应该是<code>res[tmp[i].second] += j - m - 1;</code></li>
</ol>
</li>
</ol>
</li>
<li><p>为什么和逆序对不一样：当前左数 &lt; &#x3D; 右数 , 说明右数已合并的数，都小于该左数；需要统计进去，即 res[indexes[k]] +&#x3D; (j - mid - 1);代码</p>
</li>
<li><p>忘记初始化返回vector</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">res = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(vec.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line"><span class="comment">//res =(vec.size(), 0);</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>tmp需要实现指定范围</p>
</li>
<li><p>忘记递归排序左右部分</p>
</li>
</ol>
<h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countSmaller</span><span class="params">(vector&lt;<span class="type">int</span>&gt; vec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (vec.<span class="built_in">empty</span>())    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; nums;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            nums.<span class="built_in">emplace_back</span>(vec[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">tmp</span>(vec.<span class="built_in">size</span>());</span><br><span class="line">        res = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(vec.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">mergeSort</span>(nums, <span class="number">0</span>, vec.<span class="built_in">size</span>() - <span class="number">1</span>, tmp);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&amp; tmp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r)    <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> i = l, j = m+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">mergeSort</span>(nums, l, m, tmp); <span class="built_in">mergeSort</span>(nums, m + <span class="number">1</span>, r, tmp);</span><br><span class="line">        <span class="type">int</span> k = l;</span><br><span class="line">        <span class="keyword">for</span> (k = l; k &lt;= r; k++) &#123;</span><br><span class="line">            tmp[k] = nums[k];</span><br><span class="line">        &#125;</span><br><span class="line">        k = l;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;=m&amp;&amp;j&lt;=r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp[i].first &lt;= tmp[j].first) &#123;</span><br><span class="line">                res[tmp[i].second] += j - m - <span class="number">1</span>;</span><br><span class="line">                nums[k++] = tmp[i++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                nums[k++] = tmp[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;=m)</span><br><span class="line">        &#123;</span><br><span class="line">            res[tmp[i].second] += j - m - <span class="number">1</span>;</span><br><span class="line">            nums[k++] = tmp[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=r)  nums[k++] = tmp[j++];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>新增测试</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>秋招</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2023/08/24/23-19-49/</url>
    <content><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><ol>
<li><p>种类</p>
<p>完全二叉树与满二叉树</p>
<p>平衡搜索二叉树</p>
</li>
<li><p>存储方式</p>
<p>链式存储（多用），数组存储，2*父节点+1是左孩子</p>
</li>
<li><p>遍历方式</p>
<p>深度优先：前中后是按照中间结点的顺序</p>
<p>广度优先</p>
</li>
<li><p>定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line">TreeNode* leftChild;</span><br><span class="line">TreeNode* rightChild;</span><br><span class="line"><span class="built_in">TreeNode</span>(<span class="type">int</span> x):<span class="built_in">val</span>(x),<span class="built_in">leftChild</span>(Null),<span class="built_in">rigthtChild</span>(Null)&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>三要素：参数；终止递归；单层递归逻辑</p>
<h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><ol>
<li>参数哪里不知道怎么把对应的值按顺序压到<code>vector</code>里面，直接<code>pushback</code>，这也是为什么要把<code>res</code>作为参数一起遍历；</li>
<li>传递res的时候是引用传递</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(TreeNode* root,vector&lt;<span class="type">int</span>&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)   <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">postorder</span>(root-&gt;left,res);</span><br><span class="line">        <span class="built_in">postorder</span>(root-&gt;right,res);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">postorder</span>(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h2><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历 - 力扣（LeetCode）</a></p>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>实现了对二叉树的层次遍历，将每一层的节点值存储在一个二维向量中，其中外层向量的索引表示层级，内层向量存储了该层级的节点值。</p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol>
<li><p>depth是什么作用，表示当前节点所在的层级；</p>
</li>
<li><p>在进行二叉树的层次遍历时，我们希望将每一层的节点值存储在不同的容器中，然后将这些容器存储在一个二维向量中。每个容器对应一个层级，其中容器中的元素是该层级上的节点值。</p>
<p>如果 <code>result</code> 的大小等于 <code>depth</code>，这意味着我们已经处理了 <code>depth + 1</code> 个层级（因为索引从 0 开始），但还没有为第 <code>depth + 1</code> 层创建容器。这是因为在遍历二叉树的过程中，可能会先遍历某个层级的左子树，再遍历右子树，这样就会导致先访问深度较大的层级。</p>
</li>
</ol>
<h4 id="错误-1"><a href="#错误-1" class="headerlink" title="错误"></a>错误</h4><ol>
<li><p>层级进错了：在表达式 <code>level(root-&gt;left, res, depth++);</code> 中，<code>depth++</code> 会先执行函数再加 1。</p>
</li>
<li><pre><code class="c++">level(root-&gt;left,res,++depth);
level(root-&gt;right,res,++depth);
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">如何让左右在一个层级上：应该是当前节点的深度加1</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">level(root-&gt;left,res,depth+1);</span><br><span class="line">level(root-&gt;right,res,depth+1);</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">order</span><span class="params">(TreeNode* cur, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result, <span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (result.<span class="built_in">size</span>() == depth) result.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        result[depth].<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="built_in">order</span>(cur-&gt;left, result, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">order</span>(cur-&gt;right, result, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">order</span>(root, result, depth);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="层序遍历2"><a href="#层序遍历2" class="headerlink" title="层序遍历2"></a>层序遍历2</h3><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层序遍历 II - 力扣（LeetCode）</a></p>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>102加vector反转</p>
<p>广度优先遍历的时间和空间复杂度都是O(n);</p>
<h3 id="二叉树的右视图"><a href="#二叉树的右视图" class="headerlink" title="二叉树的右视图"></a>二叉树的右视图</h3><p><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台</a></p>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>层序遍历，输出原<code>result</code>的每个元素的<code>back</code>值</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">lass Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">order</span><span class="params">(TreeNode* cur, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result, <span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (result.<span class="built_in">size</span>() == depth) result.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        result[depth].<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="built_in">order</span>(cur-&gt;left, result, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">order</span>(cur-&gt;right, result, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">order</span>(root, result, depth);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;result.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(result[i].<span class="built_in">back</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="层平均值"><a href="#层平均值" class="headerlink" title="层平均值"></a>层平均值</h3><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>原来是<code>pushback</code>新的元素，而且是二维数组，创立<code>pair</code>，第一个值存储和，第二个值存储个数；</p>
<h4 id="错误-2"><a href="#错误-2" class="headerlink" title="错误"></a>错误</h4><ol>
<li>同样也需要在新到每一层的时候初始化，但不是像初始那样预留空间，而是将<code>pair</code>赋值成<code>（0，0.0）</code></li>
<li>溢出：将<code>int</code>修改成<code>long</code></li>
</ol>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">order</span><span class="params">(TreeNode* cur, vector&lt;pair&lt;<span class="type">long</span>,<span class="type">double</span>&gt;&gt;&amp; result, <span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (result.<span class="built_in">size</span>() == depth) result.<span class="built_in">push_back</span>(<span class="built_in">pair</span>&lt;<span class="type">long</span>,<span class="type">double</span>&gt;(<span class="number">0</span>,<span class="number">0.0</span>));</span><br><span class="line">        <span class="comment">// result[depth].push_back(cur-&gt;val);</span></span><br><span class="line">        result[depth].first+=cur-&gt;val;</span><br><span class="line">        result[depth].second+=<span class="number">1.0</span>;</span><br><span class="line">        <span class="built_in">order</span>(cur-&gt;left, result, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">order</span>(cur-&gt;right, result, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">long</span>,<span class="type">double</span>&gt;&gt; result;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">order</span>(root, result, depth);</span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;result.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(result[i].first/result[i].second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树最大深度"><a href="#二叉树最大深度" class="headerlink" title="二叉树最大深度"></a>二叉树最大深度</h3><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度 - 力扣（LeetCode）</a></p>
<h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>模板</p>
<h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><p>初始化个数的问题，不能将int作为参数传入；存在浪费空间的问题</p>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">order</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; result, <span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (result.<span class="built_in">size</span>() == depth) result.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">order</span>(cur-&gt;left, result, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">order</span>(cur-&gt;right, result, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">order</span>(root, result, depth);</span><br><span class="line">        <span class="keyword">return</span> result.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="最小深度"><a href="#最小深度" class="headerlink" title="最小深度"></a>最小深度</h3><h4 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h4><ol>
<li>这个<code>minDepth</code>往哪里加才不会每次进入时都重新覆盖成0：<code>return</code>的时候初始化<code>int res=...</code></li>
<li>这个时候不适用广度搜索，深度搜索</li>
</ol>
<h4 id="错误-3"><a href="#错误-3" class="headerlink" title="错误"></a>错误</h4><ol>
<li>忘记递归返回了</li>
<li>逻辑有问题:对于root &#x3D; [3,9,20,null,null,15,7]，正确深度是2，但是如果按好<code>if(cur-&gt;left || cur-&gt;right) result[0]++;</code>算出来是3</li>
</ol>
<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> leftDepth = <span class="built_in">minDepth</span>(cur-&gt;left);</span><br><span class="line">        <span class="type">int</span> rightDepth = <span class="built_in">minDepth</span>(cur-&gt;right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (leftDepth == <span class="number">0</span> || rightDepth == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Node has only one child or no child</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(leftDepth, rightDepth) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(leftDepth, rightDepth) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>和之前写的都有一些差别是因为没拆开两个，只返回1个常数不用拆开写</p>
<h2 id="反转二叉树"><a href="#反转二叉树" class="headerlink" title="反转二叉树"></a>反转二叉树</h2><p><a href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树 - 力扣（LeetCode）</a></p>
<h3 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h3><ol>
<li><p><code>//if(root-&gt;left==nullptr &amp;&amp; root-&gt;right==nullptr) return ;</code>实际上是递归的终止条件，到叶节点会交换两个空指针，再往下遍历两个空指针，返回。</p>
</li>
<li><p>返回值的问题：<br>是的，函数的返回值可以不被接收或使用。在很多情况下，我们调用函数是为了执行其中的操作或获取其返回值，但有时候我们可能不需要使用函数的返回值，只是希望函数执行其中的某些行为。</p>
<p>这种情况下，编译器不会强制你接收函数的返回值。如果你不需要使用函数的返回值，可以简单地忽略它。但是要注意，如果函数的返回值具有副作用，例如修改了某些全局变量或执行了一些重要操作，忽略返回值可能会导致程序行为出现问题。</p>
</li>
</ol>
<h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="built_in">swap</span>(root-&gt;left,root-&gt;right); </span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h2><p><a href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树 - 力扣（LeetCode）</a></p>
<h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>递归处理，对于有返回值的递归，前面的return其实都是终止条件</p>
<h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(TreeNode* left,TreeNode* right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(right!=<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(right==<span class="literal">nullptr</span>)    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(left-&gt;val!=right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">compare</span>(left-&gt;left,right-&gt;right)&amp;&amp;<span class="built_in">compare</span>(left-&gt;right,right-&gt;left);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">compare</span>(root-&gt;left,root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="完全二叉树的节点个数"><a href="#完全二叉树的节点个数" class="headerlink" title="完全二叉树的节点个数"></a>完全二叉树的节点个数</h2><p><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数 - 力扣（LeetCode）</a></p>
<h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><ol>
<li><p>深度遍历统计节点个数</p>
</li>
<li><p>利用完全二叉树的性质</p>
<ol>
<li>左右子树中最多只有一个子树不是满二叉，且深度都是<code>log(n)</code></li>
<li>满二叉树的节点数&#x3D;2的高度次方-1，通过循环确定高度，时间复杂度<code>O(log(n))</code></li>
<li>如果当前完全二叉树不是满二叉树，递归遍历左右孩子高度，但是递归深度不是O(n),因为左右子树中最多只有一个子树不是满二叉，且深度都是<code>log(n)</code>，所以递归深度是<code>log(n)</code>，所以复杂度是<code>O(log(n)*log(n))</code></li>
</ol>
</li>
<li><p>流程：判断是否为满二叉树-不是则递归遍历左右子树</p>
</li>
</ol>
<h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">countNodes</span>(root-&gt;left)+<span class="built_in">countNodes</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> leftDepth=<span class="number">0</span>,rightDepth=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        TreeNode *leftNode=root-&gt;left,*rightNode=root-&gt;right;</span><br><span class="line">        <span class="keyword">while</span> (leftNode) &#123;</span><br><span class="line">            leftDepth++;</span><br><span class="line">            leftNode=leftNode-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (rightNode) &#123;</span><br><span class="line">            rightDepth++;</span><br><span class="line">            rightNode=rightNode-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(leftDepth==rightDepth)   <span class="keyword">return</span> (<span class="type">int</span>)<span class="built_in">pow</span>(<span class="number">2</span>,leftDepth+<span class="number">1</span>)<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">countNodes</span>(root-&gt;left)+<span class="built_in">countNodes</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p><a href="https://leetcode.cn/problems/balanced-binary-tree/">110. Balanced Binary Tree - 力扣（LeetCode）</a></p>
<h3 id="问题-4"><a href="#问题-4" class="headerlink" title="问题"></a>问题</h3><ol>
<li><p>深度与高度：之前求过二叉树最大深度，深度是指从根节点至上而下到该节点的值，高度是指从该节点到叶结点的值；</p>
<ol>
<li><p>深度采取前序遍历，单层是对叶子节点进行赋值（最小最大的区别就是返回res还是depth，比较大小）+递归逻辑</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(TreeNode* root,<span class="type">int</span> depth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)   <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">nullptr</span>&amp;&amp;root-&gt;right==<span class="literal">nullptr</span>)    res=res&gt;depth?res:depth;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)  <span class="built_in">preOrder</span>(root-&gt;left,depth+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) <span class="built_in">preOrder</span>(root-&gt;right,depth+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">preOrder</span>(root, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>高度采取后序遍历</p>
</li>
</ol>
</li>
<li><p>前序遍历与后序遍历的区别就是先递归还是先处理单层逻辑</p>
</li>
</ol>
<h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3><p>采取后序遍历，得先知道左右子树的高度</p>
<h3 id="错误-4"><a href="#错误-4" class="headerlink" title="错误"></a>错误</h3><ol>
<li><p>返回值写错</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">abs</span>(leftHeight-rightHeight)&lt;<span class="number">1</span>?leftHeight+<span class="number">1</span>:<span class="number">-1</span>;</span><br></pre></td></tr></table></figure>

<p>正确的应该是</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">abs</span>(leftHeight-rightHeight)&lt;<span class="number">1</span>?<span class="built_in">max</span>(leftHeight,rightHeight)+<span class="number">1</span>:<span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>高度差不是小于1而是小于等于1</p>
</li>
</ol>
<h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getHeight</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftHeight=<span class="built_in">getHeight</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> rightHeight=<span class="built_in">getHeight</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(leftHeight==<span class="number">-1</span>||rightHeight==<span class="number">-1</span>)  <span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(leftHeight-rightHeight)&lt;=<span class="number">1</span>?<span class="built_in">max</span>(leftHeight,rightHeight)+<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getHeight</span>(root)==<span class="number">-1</span>?<span class="literal">false</span>:<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的所有路径"><a href="#二叉树的所有路径" class="headerlink" title="二叉树的所有路径"></a>二叉树的所有路径</h2><p><a href="https://leetcode.cn/problems/binary-tree-paths/">257. 二叉树的所有路径 - 力扣（LeetCode）</a></p>
<h3 id="问题-5"><a href="#问题-5" class="headerlink" title="问题"></a>问题</h3><ol>
<li>回溯：需要记录路径，需要回溯回退在进入另外一个路径：如何回退：入站的可能不止一个，1 23 45，在每个中间节点都回溯，，一层一层来的，不会发生一次性需要pop多个数值的情况</li>
<li>终止处理逻辑当遇到叶结点时停止递归，这时候叶节点是不是还没进入path呢：在终止逻辑之前进行入栈</li>
<li>能不能改成终止条件正常<code>root==nullptr</code>：这样空节点不入栈，回溯pop丢掉叶子节点</li>
</ol>
<h3 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h3><p>前序遍历，递归：参数一个记录路径，一个存放结果；当遍历到叶结点时即进行打印操作，对于中间节点单层循环push进入path里，递归遍历左子树后回溯</p>
<h3 id="错误-5"><a href="#错误-5" class="headerlink" title="错误"></a>错误</h3><ol>
<li>终止处理逻辑时，将路径转成字符串<code>sPath</code>，不能直接给结果<code>pushback</code>；</li>
<li><code>use of undeclared identifier &#39;tostring&#39;—— to_string</code></li>
</ol>
<h3 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; path, vector&lt;string&gt;&amp; result)</span></span>&#123;</span><br><span class="line">        path.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;left==<span class="literal">nullptr</span>&amp;&amp;cur-&gt;right==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            string sPath;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;path.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">                sPath+=<span class="built_in">to_string</span>(path[i]);</span><br><span class="line">                sPath+=<span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sPath+=<span class="built_in">to_string</span>(path[path.<span class="built_in">size</span>()<span class="number">-1</span>]);</span><br><span class="line">            result.<span class="built_in">push_back</span>(sPath);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;left)&#123;</span><br><span class="line">            <span class="built_in">traversal</span>(cur-&gt;left,path,result);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;right)&#123;</span><br><span class="line">            <span class="built_in">traversal</span>(cur-&gt;right,path,result);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">traversal</span>(root,path,result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="左叶子之和"><a href="#左叶子之和" class="headerlink" title="左叶子之和"></a>左叶子之和</h2><p><a href="https://leetcode.cn/problems/sum-of-left-leaves/">404. 左叶子之和 - 力扣（LeetCode）</a></p>
<h3 id="问题-6"><a href="#问题-6" class="headerlink" title="问题"></a>问题</h3><ol>
<li>跟之前见过的二叉树右视图不一样，不是层序遍历；后序遍历</li>
<li>单层处理逻辑需要干什么：感觉不需要干什么</li>
<li>怎么判断是不是左叶子节点：<ol>
<li>左叶子定义：当前节点的左孩子不为空而且左孩子的左右孩子都为空</li>
</ol>
</li>
</ol>
<h3 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h3><p>后序遍历，终止条件：当前节点为空；单层逻辑：判断左叶子节点并累加，</p>
<h3 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(TreeNode* cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;left&amp;&amp;cur-&gt;left-&gt;left==<span class="literal">nullptr</span>&amp;&amp;</span><br><span class="line">        cur-&gt;left-&gt;right==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            res+=cur-&gt;left-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">preOrder</span>(cur-&gt;left);</span><br><span class="line">        <span class="built_in">preOrder</span>(cur-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">preOrder</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="找树左下角的值"><a href="#找树左下角的值" class="headerlink" title="找树左下角的值"></a>找树左下角的值</h2><p><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">513. 找树左下角的值 - 力扣（LeetCode）</a></p>
<h3 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h3><ol>
<li>借用层序遍历的二维数组</li>
<li>占用的内存有点大</li>
</ol>
<h3 id="错误-6"><a href="#错误-6" class="headerlink" title="错误"></a>错误</h3><ol>
<li>忘记引用传递二维数组</li>
<li>容器的<code>back</code>和<code>front</code>，没有<code>top</code></li>
</ol>
<h3 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">order</span><span class="params">(TreeNode* cur,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; res,<span class="type">int</span> depth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur==<span class="literal">nullptr</span>)    <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(res.<span class="built_in">size</span>()==depth)   res.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        res[depth].<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="built_in">order</span>(cur-&gt;left,res,depth+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">order</span>(cur-&gt;right,res,depth+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="type">int</span> depth=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">order</span>(root,res,depth);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">back</span>().<span class="built_in">front</span>();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h2><p><a href="https://leetcode.cn/problems/path-sum/">112. 路径总和 - 力扣（LeetCode）</a></p>
<h3 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h3><p>之前敲过一个路径数组</p>
<h3 id="错误-7"><a href="#错误-7" class="headerlink" title="错误"></a>错误</h3><ol>
<li><p><code>vector</code>下没有<code>find</code>函数，有库函数</p>
</li>
<li><p><code>AddressSanitizer: stack-overflow</code>,没更新<code>cur</code></p>
</li>
<li><p>返回false：</p>
<ol>
<li><p><code>targetSum</code>隐式回溯了，因为并不会修改它的值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, <span class="type">int</span> targetSum, <span class="type">bool</span>&amp; res)</span> </span>&#123;</span><br><span class="line">       targetSum -= cur-&gt;val;</span><br><span class="line">       <span class="keyword">if</span> (cur-&gt;left == <span class="literal">nullptr</span> &amp;&amp; cur-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (res==<span class="literal">false</span>)</span><br><span class="line">               res = targetSum == <span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">           <span class="built_in">traversal</span>(cur-&gt;left, targetSum, res);</span><br><span class="line">           </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">           <span class="built_in">traversal</span>(cur-&gt;right, targetSum, res);</span><br><span class="line">          </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">      </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<ol>
<li><p>如果修改成随着迭代变化，那么就需要回溯了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, <span class="type">int</span>&amp;targetSum, <span class="type">bool</span>&amp; res)</span> </span>&#123;</span><br><span class="line">    targetSum -= cur-&gt;val;</span><br><span class="line">    <span class="keyword">if</span> (cur-&gt;left == <span class="literal">nullptr</span> &amp;&amp; cur-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (res==<span class="literal">false</span>)</span><br><span class="line">            res = targetSum == <span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left, targetSum, res);</span><br><span class="line">        targetSum += cur-&gt;left-&gt;val;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right, targetSum, res);</span><br><span class="line">        targetSum += cur-&gt;right-&gt;val;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>每次遇到叶节点都新去修改<code>res</code>的值，导致即使左子树<code>true</code>。右子树找不到最后返回<code>false</code>：加个判断条件：判断当前值是不是<code>false</code>，true就不用修改了</p>
</li>
</ol>
</li>
</ol>
<h3 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur,vector&lt;<span class="type">int</span>&gt;&amp; path,vector&lt;<span class="type">int</span>&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        path.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;left==<span class="literal">nullptr</span>&amp;&amp;cur-&gt;right==<span class="literal">nullptr</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;path.<span class="built_in">size</span>();i++)</span><br><span class="line">                sum+=path[i];</span><br><span class="line">            res.<span class="built_in">push_back</span>(sum);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;left)&#123;</span><br><span class="line">            <span class="built_in">traversal</span>(cur-&gt;left,path,res);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;right)&#123;</span><br><span class="line">            <span class="built_in">traversal</span>(cur-&gt;right,path,res);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">traversal</span>(root,path,res);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>(),targetSum)!=res.<span class="built_in">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">createTree</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nodes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nodes.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nodes[<span class="number">0</span>]);</span><br><span class="line">        queue&lt;TreeNode*&gt; nodeQueue;</span><br><span class="line">        nodeQueue.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!nodeQueue.<span class="built_in">empty</span>() &amp;&amp; i &lt; nodes.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            TreeNode* current = nodeQueue.<span class="built_in">front</span>();</span><br><span class="line">            nodeQueue.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nodes[i] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                current-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nodes[i]);</span><br><span class="line">                nodeQueue.<span class="built_in">push</span>(current-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &lt; nodes.<span class="built_in">size</span>() &amp;&amp; nodes[i] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                current-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nodes[i]);</span><br><span class="line">                nodeQueue.<span class="built_in">push</span>(current-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, <span class="type">int</span>&amp;targetSum, <span class="type">bool</span>&amp; res)</span> </span>&#123;</span><br><span class="line">    targetSum -= cur-&gt;val;</span><br><span class="line">    <span class="keyword">if</span> (cur-&gt;left == <span class="literal">nullptr</span> &amp;&amp; cur-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (res==<span class="literal">false</span>)</span><br><span class="line">            res = targetSum == <span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left, targetSum, res);</span><br><span class="line">        targetSum += cur-&gt;left-&gt;val;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right, targetSum, res);</span><br><span class="line">        targetSum += cur-&gt;right-&gt;val;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">bool</span> res=<span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">traversal</span>(root, targetSum, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><em>另外在VS调试的时候可以遍历创建树，根据输入的是vector，创建出链表</em></p>
<h2 id="中序后序遍历创建树"><a href="#中序后序遍历创建树" class="headerlink" title="中序后序遍历创建树"></a>中序后序遍历创建树</h2><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树 - 力扣（LeetCode）</a></p>
<h3 id="问题-7"><a href="#问题-7" class="headerlink" title="问题"></a>问题</h3><ol>
<li>和前序不一样的是顺序没那么顺畅–不是这个原因，是因为满二叉树的建立是唯一的，但是普通二叉树的建立就不唯一，需要两种遍历才知道</li>
<li>后序遍历从后面开始划分，最后一个节点就是根节点，根据后序遍历的根节点去中序序列找到左右子树的区间，再去右子树遍历顺序里找到左右区间<ol>
<li>区间怎么划分：中序遍历划分出来左中序和右中序之后，对于后序的划分：大小是一样的</li>
<li>区间的划分一定要遵循循环不变量<ol>
<li>左闭右开</li>
<li>最初始的不是左闭右闭吗？</li>
</ol>
</li>
</ol>
</li>
<li>C++如何找到vector中指定元素的下标：find返回迭代器，distance计算距离</li>
</ol>
<h3 id="错误-8"><a href="#错误-8" class="headerlink" title="错误"></a>错误</h3><ol>
<li>终止情况如果设置为叶结点：对于{2，1}这种情况只有左叶子没有右叶子，会出错</li>
</ol>
<h3 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h3><ol>
<li>获取根节点</li>
<li>中序划分</li>
<li>后序划分</li>
</ol>
<h3 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (postorder.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> rootVal = postorder[postorder.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">        TreeNode* root=<span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootVal);</span><br><span class="line">        <span class="type">int</span> rootIndex;</span><br><span class="line">        <span class="comment">//找到根节点在中序遍历的位置</span></span><br><span class="line">        <span class="keyword">for</span> (rootIndex = <span class="number">0</span>; rootIndex &lt; inorder.<span class="built_in">size</span>(); rootIndex++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[rootIndex] == rootVal) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//划分中序遍历区间</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftInorder</span><span class="params">(inorder.begin(), inorder.begin() + rootIndex)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightInorder</span><span class="params">(inorder.begin()+rootIndex+<span class="number">1</span>, inorder.end())</span></span>;</span><br><span class="line">        <span class="type">int</span> leftSize = leftInorder.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> rightSize = rightInorder.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//划分后序遍历区间</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftPostorder</span><span class="params">(postorder.begin(), postorder.begin() + leftSize)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightPostorder</span><span class="params">(postorder.begin() + leftSize, postorder.end() - <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">//递归遍历左右</span></span><br><span class="line">        root-&gt;left = <span class="built_in">buildTree</span>(leftInorder,leftPostorder);</span><br><span class="line">        root-&gt;right = <span class="built_in">buildTree</span>(rightInorder,rightPostorder);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a>最大二叉树</h2><h3 id="问题-8"><a href="#问题-8" class="headerlink" title="问题"></a>问题</h3><ol>
<li><code>rootVal</code>为空的时候怎么处理：递归结束了早已经</li>
</ol>
<h3 id="错误-9"><a href="#错误-9" class="headerlink" title="错误"></a>错误</h3><ol>
<li>数组访问越界：<code>rootIndex</code>没有初始化：当只有0这一个节点时，不会给<code>rootIndex</code>赋值</li>
</ol>
<h3 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h3><p>和上一道题一样，选择最大的数值，获取<code>index</code>，分割左右数组，递归</p>
<h3 id="代码-15"><a href="#代码-15" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//选择最大的数值</span></span><br><span class="line">        <span class="comment">//获取index</span></span><br><span class="line">        <span class="type">int</span> rootVal = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> rootIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rootVal &lt; nums[i]) &#123;</span><br><span class="line">                rootVal = nums[i];</span><br><span class="line">                rootIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootVal);</span><br><span class="line">        <span class="comment">//分割左右数组</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftNums</span><span class="params">(nums.begin(), nums.begin() + rootIndex)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightNums</span><span class="params">(nums.begin() + rootIndex + <span class="number">1</span>, nums.end())</span></span>;</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        root-&gt;left = <span class="built_in">constructMaximumBinaryTree</span>(leftNums);</span><br><span class="line">        root-&gt;right = <span class="built_in">constructMaximumBinaryTree</span>(rightNums);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h2><p><a href="https://leetcode.cn/problems/merge-two-binary-trees/">617. 合并二叉树 - 力扣（LeetCode）</a></p>
<h3 id="问题-9"><a href="#问题-9" class="headerlink" title="问题"></a>问题</h3><ol>
<li>合并的时候由左有右，判断左右是否为空</li>
<li>如何同时遍历两个树：传入两个参数</li>
</ol>
<h3 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h3><p>递归：</p>
<ol>
<li>参数：两个树的根节点</li>
<li>单层逻辑：新建树                                            </li>
<li>终止条件：两个都为空</li>
</ol>
<h3 id="错误-10"><a href="#错误-10" class="headerlink" title="错误"></a>错误</h3><ol>
<li>递归的时候没有考虑空指针：一开始改正的时候直接<code>new treeNode</code>，但是这样还是会访问空指针,交给递归处理。</li>
</ol>
<h3 id="代码-16"><a href="#代码-16" class="headerlink" title="代码"></a>代码</h3>  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (root1 == root2 &amp;&amp; root1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//单层处理逻辑</span></span><br><span class="line">        <span class="type">int</span> rootVal;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (root1 != <span class="literal">nullptr</span> &amp;&amp; root2 != <span class="literal">nullptr</span>)    rootVal = root1-&gt;val + root2-&gt;val;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root1 != <span class="literal">nullptr</span> &amp;&amp; root2 == <span class="literal">nullptr</span>)   rootVal = root1-&gt;val;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root1 == <span class="literal">nullptr</span> &amp;&amp; root2 != <span class="literal">nullptr</span>)   rootVal = root2-&gt;val;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        TreeNode* newRoot = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootVal);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        <span class="keyword">if</span> (root1 != <span class="literal">nullptr</span> &amp;&amp; root2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            newRoot-&gt;left = <span class="built_in">mergeTrees</span>(root1-&gt;left, root2-&gt;left);</span><br><span class="line">            newRoot-&gt;right = <span class="built_in">mergeTrees</span>(root1-&gt;right, root2-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root1 != <span class="literal">nullptr</span> &amp;&amp; root2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            newRoot-&gt;left = <span class="built_in">mergeTrees</span>(root1-&gt;left, <span class="literal">nullptr</span>);</span><br><span class="line">            newRoot-&gt;right = <span class="built_in">mergeTrees</span>(root1-&gt;right, <span class="literal">nullptr</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root1 == <span class="literal">nullptr</span> &amp;&amp; root2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            newRoot-&gt;left = <span class="built_in">mergeTrees</span>(<span class="literal">nullptr</span>,root2-&gt;left);</span><br><span class="line">            newRoot-&gt;right = <span class="built_in">mergeTrees</span>(<span class="literal">nullptr</span>,root2-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树中的搜索"><a href="#二叉树中的搜索" class="headerlink" title="二叉树中的搜索"></a>二叉树中的搜索</h2><p><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索 - 力扣（LeetCode）</a></p>
<h3 id="问题-10"><a href="#问题-10" class="headerlink" title="问题"></a>问题</h3><ol>
<li><p>二叉搜索树的性质：左根右，按值排序</p>
<ol>
<li>如何利用：小到左子树</li>
</ol>
</li>
<li><p>返回值问题：在VS上是好使的，在<code>LIKOU</code>上不好使说是缺少返回值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (root-&gt;val &gt; val) <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;left, val);</span><br><span class="line"><span class="keyword">if</span> (root-&gt;val &lt; val) <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;right, val);</span><br></pre></td></tr></table></figure>
</li>
<li><p>先判断是否为空否则访问空指针</p>
</li>
</ol>
<h3 id="思路-16"><a href="#思路-16" class="headerlink" title="思路"></a>思路</h3><p>递归：</p>
<ol>
<li><p>参数：目标树以及要搜索的值，返回一个根节点</p>
</li>
<li><p>单层逻辑： val与root比较大小                                           </p>
</li>
<li><p>终止条件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>||root-&gt;val == targetVal )    <span class="keyword">return</span> root;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="代码-17"><a href="#代码-17" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> targetVal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>||root-&gt;val == targetVal)    <span class="keyword">return</span> root;</span><br><span class="line">    TreeNode* result=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &gt; targetVal)    result=<span class="built_in">searchBST</span>(root-&gt;left, targetVal);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val &lt; targetVal)  result = <span class="built_in">searchBST</span>(root-&gt;right, targetVal);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">   </span><br><span class="line">&#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="验证搜索二叉树"><a href="#验证搜索二叉树" class="headerlink" title="验证搜索二叉树"></a>验证搜索二叉树</h2><p><a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树 - 力扣（LeetCode）</a></p>
<h3 id="问题-11"><a href="#问题-11" class="headerlink" title="问题"></a>问题</h3><ol>
<li>返回值问题<ol>
<li>不是后序遍历，是中序遍历</li>
</ol>
</li>
<li>代码写得太多了：<ol>
<li>三个三个比较可以拆成两个两个，不能三个三个比较，这样不能保证<code>[5,4,6,null,null,3,7]</code>这种情况<ol>
<li><code>pre</code>的赋值：对于左子树的判断不包括与当前根节点值的判断，中序遍历：左中右：在中的处理逻辑中更新<code>pre</code>，<del>保证递归结束之后始终指向根节点</del>，指向前一个结点</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="思路-17"><a href="#思路-17" class="headerlink" title="思路"></a>思路</h3><p>递归：</p>
<ol>
<li>单层逻辑：中序遍历，遍历左子树判断左子树是否为搜索树，<code>pre</code>指向前一个遍历过的节点，遍历右子树</li>
<li>终止条件：空指针结束</li>
</ol>
<h3 id="代码-18"><a href="#代码-18" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode *pre=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">bool</span> left = <span class="built_in">isValidBST</span>(root-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="literal">nullptr</span> &amp;&amp; !(pre-&gt;val &lt; root-&gt;val)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    pre = root;</span><br><span class="line">    <span class="type">bool</span> right = <span class="built_in">isValidBST</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> left &amp;&amp; right;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二叉搜索树的最小绝对差"><a href="#二叉搜索树的最小绝对差" class="headerlink" title="二叉搜索树的最小绝对差"></a>二叉搜索树的最小绝对差</h2><p><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差 - 力扣（LeetCode）</a></p>
<h3 id="问题-12"><a href="#问题-12" class="headerlink" title="问题"></a>问题</h3><ol>
<li>终止条件：返回最大值</li>
<li>解答错误<code>1,NULL,5,3</code>:返回值类型敲错了</li>
</ol>
<h3 id="思路-18"><a href="#思路-18" class="headerlink" title="思路"></a>思路</h3><p>中序遍历记录有序数组及其差：不行这样太浪费空间</p>
<p>中序遍历：左中差以及左子树的最小差值，右子树的最小差值（包括与当前根节点的差值）</p>
<h3 id="代码-19"><a href="#代码-19" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* cur)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) <span class="keyword">return</span> MAX;</span><br><span class="line">    <span class="type">int</span> result = MAX;</span><br><span class="line">    <span class="type">int</span>  leftDif = <span class="built_in">getMinimumDifference</span>(cur-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        result = leftDif &lt; (cur-&gt;val - pre-&gt;val) ? leftDif : cur-&gt;val - pre-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = cur;</span><br><span class="line">    <span class="type">int</span> rightDif = <span class="built_in">getMinimumDifference</span>(cur-&gt;right);</span><br><span class="line">    result = result &lt; rightDif ? result : rightDif;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉搜索树中的众数"><a href="#二叉搜索树中的众数" class="headerlink" title="二叉搜索树中的众数"></a>二叉搜索树中的众数</h2><p><a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">501. 二叉搜索树中的众数 - 力扣（LeetCode）</a></p>
<h3 id="思路-19"><a href="#思路-19" class="headerlink" title="思路"></a>思路</h3><p>中序遍历，并用<code>pre</code>记录前一个节点，<code>count</code> 记录当前节点值的出现次数，<code>maxCount</code>记录最大频率，与前一个值相同则加一，不同置1。</p>
<h3 id="错误-11"><a href="#错误-11" class="headerlink" title="错误"></a>错误</h3><ol>
<li>记录最大频率而不是所有重复数字</li>
</ol>
<h3 id="代码-20"><a href="#代码-20" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="type">int</span> maxCount = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">findMode</span>(cur-&gt;left);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="literal">NULL</span>) &#123; <span class="comment">// 第一个节点</span></span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pre-&gt;val == cur-&gt;val) &#123; <span class="comment">// 与前一个节点数值相同</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 与前一个节点数值不同</span></span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count == maxCount) res.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (count &gt; maxCount) &#123;</span><br><span class="line">            res.<span class="built_in">clear</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">            maxCount = count;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="built_in">findMode</span>(cur-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h2><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先 - 力扣（LeetCode）</a></p>
<h3 id="思路-20"><a href="#思路-20" class="headerlink" title="思路"></a>思路</h3><p>层序遍历利用满二叉树的性质建立完全二叉树数组，不行因为人返回的是一个链表</p>
<p><strong>自底向上</strong>后序遍历，在左右子树中分别寻找目标节点，分四种情况实际上就三种：左子树找到1个+右子树找到一个，此时根节点即为最近公共祖先；左没找到右找到<code>如果返回值left为空，right不为空为什么要返回right</code></p>
<p>必然要遍历整棵二叉树，即使已经找到结果了，依然要把其他节点遍历完，因为要使用递归函数的返回值（也就是代码中的left和right）做逻辑判断</p>
<h3 id="错误-12"><a href="#错误-12" class="headerlink" title="错误"></a>错误</h3><ol>
<li><p>老是提示没有返回值</p>
<p>这段代码实现了一个在二叉树中查找两个节点的最低共同祖先（<code>Lowest Common Ancestor</code>）的函数。代码逻辑基本正确，但是有一个小问题：在最后一个 <code>else if</code> 分支中，没有返回值。</p>
<p>else if 别放最后，得有个<code>else</code>。</p>
</li>
</ol>
<h3 id="代码-21"><a href="#代码-21" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">       <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="literal">nullptr</span> || root == p || root == q)   <span class="keyword">return</span> root;</span><br><span class="line">       TreeNode* left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">       TreeNode* right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">       <span class="keyword">if</span> (left != <span class="literal">nullptr</span> &amp;&amp; right != <span class="literal">nullptr</span>) <span class="keyword">return</span> root;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="literal">nullptr</span> &amp;&amp; right != <span class="literal">nullptr</span>) <span class="keyword">return</span> right;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>) <span class="keyword">return</span> left;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二叉搜索树的公共祖先"><a href="#二叉搜索树的公共祖先" class="headerlink" title="二叉搜索树的公共祖先"></a>二叉搜索树的公共祖先</h2><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先 - 力扣（LeetCode）</a></p>
<h3 id="思路-21"><a href="#思路-21" class="headerlink" title="思路"></a>思路</h3><p>利用二叉搜索树的性质：从上向下去递归遍历，第一次遇到 cur节点是数值在[p, q]区间中，那么cur就是 p和q的最近公共祖先。</p>
<h3 id="代码-22"><a href="#代码-22" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">     <span class="keyword">if</span> (p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;left,p,q);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &lt; q-&gt;val &amp;&amp; root-&gt;val &lt; p-&gt;val) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">return</span> root;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二叉搜索树的插入"><a href="#二叉搜索树的插入" class="headerlink" title="二叉搜索树的插入"></a>二叉搜索树的插入</h2><p><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作 - 力扣（LeetCode）</a></p>
<h3 id="问题-13"><a href="#问题-13" class="headerlink" title="问题"></a>问题</h3><ol>
<li><p>找到该插入的位置之后怎么从下往上返回：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> root;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="思路-22"><a href="#思路-22" class="headerlink" title="思路"></a>思路</h3><p>插入是很简单的，不会像删除那样造成不是二叉搜索树的情况</p>
<h3 id="代码-23"><a href="#代码-23" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &lt; val) root-&gt;right = <span class="built_in">insertIntoBST</span>(root-&gt;right, val);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &gt; val) root-&gt;left = <span class="built_in">insertIntoBST</span>(root-&gt;left, val);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二叉搜索树的删除"><a href="#二叉搜索树的删除" class="headerlink" title="二叉搜索树的删除"></a>二叉搜索树的删除</h2><p><a href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点 - 力扣（LeetCode）</a></p>
<h3 id="思路-23"><a href="#思路-23" class="headerlink" title="思路"></a>思路</h3><ol>
<li>先序遍历</li>
<li>删除分的情况较多<ol>
<li>没找到：遍历到空节点直接返回原根节点</li>
<li>找到<ol>
<li>左右孩子是否为空<ol>
<li>都为空：直接删除</li>
<li>只有一个为空：孩子顶上</li>
<li>都不为空：将左孩子整体放到删除节点的右子树的最左面节点的左孩子的位置</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="错误-13"><a href="#错误-13" class="headerlink" title="错误"></a>错误</h3><ol>
<li><p>都不为空，循环找最左节点时出现访问空指针的错误：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">TreeNode* node= right-&gt;left;</span><br><span class="line"><span class="keyword">while</span> (node) &#123;</span><br><span class="line">    node = node-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line">node-&gt;left = left;</span><br></pre></td></tr></table></figure>

<p>修改成</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (node-&gt;left) &#123;</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            node-&gt;left = left;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="代码-24"><a href="#代码-24" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)   <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == key) &#123;</span><br><span class="line">        TreeNode* left = root-&gt;left;</span><br><span class="line">        TreeNode* right = root-&gt;right;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> root;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> root;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="literal">nullptr</span> &amp;&amp; right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> root;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            TreeNode* node= right;</span><br><span class="line">            <span class="keyword">while</span> (node-&gt;left) &#123;</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            node-&gt;left = left;</span><br><span class="line">            <span class="keyword">delete</span> root;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &gt; key) &#123;</span><br><span class="line">        root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="修剪二叉树"><a href="#修剪二叉树" class="headerlink" title="修剪二叉树"></a>修剪二叉树</h2><p><a href="https://leetcode.cn/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树 - 力扣（LeetCode）</a></p>
<h3 id="问题-14"><a href="#问题-14" class="headerlink" title="问题"></a>问题</h3><ol>
<li>并没有真正删除所在空间，题目没要求，但是删除那道题明确指出删除所在空间</li>
</ol>
<h3 id="思路-24"><a href="#思路-24" class="headerlink" title="思路"></a>思路</h3><p>比较<code>root-&gt;val</code>和<code>[low,high]</code>，在这个区间内递归修建左右子树，<code>root-&gt;val&lt;low</code>但是右子树可能在区间内，递归删除右子树并将其作为新根节点<code>root-&gt;val&gt;high</code>同理</p>
<h3 id="代码-25"><a href="#代码-25" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function">TreeNode* <span class="title">trimBST</span><span class="params">(TreeNode* root, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">     <span class="keyword">if</span> (root-&gt;val &lt; low) <span class="keyword">return</span> <span class="built_in">trimBST</span>(root-&gt;right, low, high);</span><br><span class="line">     <span class="keyword">if</span> (root-&gt;val &gt; high) <span class="keyword">return</span> <span class="built_in">trimBST</span>(root-&gt;left, low, high);</span><br><span class="line">     root-&gt;left = <span class="built_in">trimBST</span>(root-&gt;left, low, high);</span><br><span class="line">     root-&gt;right = <span class="built_in">trimBST</span>(root-&gt;right, low, high);</span><br><span class="line">     <span class="keyword">return</span> root;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="有序数组转换为二叉搜索树"><a href="#有序数组转换为二叉搜索树" class="headerlink" title="有序数组转换为二叉搜索树"></a>有序数组转换为二叉搜索树</h2><p><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树 - 力扣（LeetCode）</a></p>
<h3 id="问题-15"><a href="#问题-15" class="headerlink" title="问题"></a>问题</h3><ol>
<li>保证平衡：数组砍半作为根节点</li>
</ol>
<h3 id="思路-25"><a href="#思路-25" class="headerlink" title="思路"></a>思路</h3><p>寻找分割点，分割点作为当前节点，然后递归左区间和右区间；保证平衡+循环不变量</p>
<h3 id="代码-26"><a href="#代码-26" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> rootIndex = nums.<span class="built_in">size</span>() / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> rootVal = nums[rootIndex];</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftNums</span><span class="params">(nums.begin(), nums.begin() + rootIndex)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightNums</span><span class="params">(nums.begin() + rootIndex + <span class="number">1</span>, nums.end())</span></span>;</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootVal);</span><br><span class="line">    root-&gt;left = <span class="built_in">sortedArrayToBST</span>(leftNums);</span><br><span class="line">    root-&gt;right = <span class="built_in">sortedArrayToBST</span>(rightNums);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二叉搜索树转累加树"><a href="#二叉搜索树转累加树" class="headerlink" title="二叉搜索树转累加树"></a>二叉搜索树转累加树</h2><p><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树 - 力扣（LeetCode）</a></p>
<h3 id="问题-16"><a href="#问题-16" class="headerlink" title="问题"></a>问题</h3><ol>
<li>累加树：<ol>
<li>存储类型： 2^31 - 1 约等于 10^9，节点数10^4，节点值10^4，可以用int存储不会超出去</li>
</ol>
</li>
</ol>
<h3 id="思路-26"><a href="#思路-26" class="headerlink" title="思路"></a>思路</h3><p>中序遍历转成有序数组，用next记录右边的节点，右：计算右子树；中：更新next和节点值；左：递归计算左子树</p>
<h3 id="代码-27"><a href="#代码-27" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode* next = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    root-&gt;right = <span class="built_in">convertBST</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">if</span> (next) &#123;</span><br><span class="line">        root-&gt;val = next-&gt;val + root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    next = root;</span><br><span class="line">    root-&gt;left = <span class="built_in">convertBST</span>(root-&gt;left);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>秋招</tag>
      </tags>
  </entry>
</search>
